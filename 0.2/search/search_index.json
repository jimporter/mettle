{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mettle \u00a7 mettle is a \"batteries included\" unit testing framework for C++17. Its mission is to provide a full toolbox to address your testing needs and to look good doing it. Features \u00a7 Build your own assertions \u00a7 Expectations (assertions) are defined using composable matchers that automatically generate human-readable output, ensuring even complex objects are easy to test. Nest your tests \u00a7 Suites group your tests together and can be nested as deeply as you need, so you can use their hierarchy to set up and tear down your fixtures for you. Don't repeat yourself \u00a7 Type- and value-parameterized tests let you write your tests once and apply them to multiple implementations or preconditions. Aggregate everything \u00a7 The mettle universal test runner makes it a snap to write multiple, independent test files \u2013 even ones running completely different kinds of tests \u2013 and aggregate them into a single list of results. A brief example \u00a7 A picture is worth a thousand words, and code's almost as good (I'm sure it's worth at least 100 words), so let's take a look at a test file: #include <mettle.hpp> using namespace mettle; suite<> basic(\"a basic suite\", [](auto &_) { _.test(\"a test\", []() { expect(true, equal_to(true)); }); for(int i = 0; i < 4; i++) { _.test(\"test number \" + std::to_string(i), [i]() { expect(i % 2, less(2)); }); } subsuite<>(_, \"a subsuite\", [](auto &_) { _.test(\"a sub-test\", []() { expect(true, equal_to(true)); }); }); }); For further examples, please see the examples/ subdirectory.","title":"Home"},{"location":"#mettle","text":"mettle is a \"batteries included\" unit testing framework for C++17. Its mission is to provide a full toolbox to address your testing needs and to look good doing it.","title":"mettle"},{"location":"#features","text":"","title":"Features"},{"location":"#build-your-own-assertions","text":"Expectations (assertions) are defined using composable matchers that automatically generate human-readable output, ensuring even complex objects are easy to test.","title":"Build your own assertions"},{"location":"#nest-your-tests","text":"Suites group your tests together and can be nested as deeply as you need, so you can use their hierarchy to set up and tear down your fixtures for you.","title":"Nest your tests"},{"location":"#dont-repeat-yourself","text":"Type- and value-parameterized tests let you write your tests once and apply them to multiple implementations or preconditions.","title":"Don't repeat yourself"},{"location":"#aggregate-everything","text":"The mettle universal test runner makes it a snap to write multiple, independent test files \u2013 even ones running completely different kinds of tests \u2013 and aggregate them into a single list of results.","title":"Aggregate everything"},{"location":"#a-brief-example","text":"A picture is worth a thousand words, and code's almost as good (I'm sure it's worth at least 100 words), so let's take a look at a test file: #include <mettle.hpp> using namespace mettle; suite<> basic(\"a basic suite\", [](auto &_) { _.test(\"a test\", []() { expect(true, equal_to(true)); }); for(int i = 0; i < 4; i++) { _.test(\"test number \" + std::to_string(i), [i]() { expect(i % 2, less(2)); }); } subsuite<>(_, \"a subsuite\", [](auto &_) { _.test(\"a sub-test\", []() { expect(true, equal_to(true)); }); }); }); For further examples, please see the examples/ subdirectory.","title":"A brief example"},{"location":"built-in-matchers/","text":"Built-in Matchers \u00a7 Mettle comes with a set of general-purpose matchers that should cover the most common cases. We'll look at each of them below. The entire set of matchers can be included via #include <mettle/matchers.hpp> , or you can include just the categories you need by including the appropriate file (e.g. #include <mettle/matchers/combinatoric.hpp ). Core \u00a7 <mettle/matchers/core.hpp> anything() \u00a7 A matcher that always returns true . This is useful primarily as a placeholder, e.g. when you can't know for sure what an expected value is going to be, but you still want to test it. is_not( matcher ) \u00a7 A matcher that negates another matcher. describe( matcher , desc ) \u00a7 A matcher that overrides the description of another matcher. desc is a string describing the resulting matcher. This can be useful for when the default description is unclear or overly-verbose. filter( func , matcher [, desc ]) \u00a7 A matcher that filters the expected value through a function before passing it to another matcher. This helps when creating complex matchers that test multiple parts of a type, such as: all( filter([](auto &&x) { return x.first; }, equal_to(\"first\")), filter([](auto &&x) { return x.second; }, greater(0)) ); Additionally, you may pass in a string for desc , which will be added as a prefix to matcher 's description. This helps provide useful output explaining what exactly func is doing to the expected value. Relational \u00a7 <mettle/matchers/relational.hpp> equal_to( value ) \u00a7 A matcher that returns true when the actual value is equal to value according to the == operator. Note equal_to is also the implicit matcher . Any time a matcher takes another matcher as an argument, you can pass in a value, and it will be implicitly converted to equal_to(value) . This doesn't work for the root matcher; you need to explicitly say equal_to(value) in that case. not_equal_to( value ) \u00a7 A matcher that returns true when the actual value is not equal to value according to the != operator. greater( value ) \u00a7 A matcher that returns true when the actual value is greater than value according to the > operator. greater_equal( value ) \u00a7 A matcher that returns true when the actual value is greater than or equal to value according to the >= operator. less( value ) \u00a7 A matcher that returns true when the actual value is less than value according to the < operator. less_equal( value ) \u00a7 A matcher that returns true when the actual value is less than or equal to value according to the <= operator. Arithmetic \u00a7 <mettle/matchers/arithmetic.hpp> near_to( value [, epsilon ]) \u00a7 A matcher that returns true when the actual value is approximately equal to value , specifically when: auto mag = std::max<T>(std::abs(expected), std::abs(actual)); std::abs(actual - expected) <= mag * epsilon; If epsilon is not specified, it defaults to std::numeric_limits<T>::epsilon() * 10 . Warning As with most functions that check if two floating point numbers are approximately equal, this matcher will likely fail if one of the values is zero. In that case, use near_to_abs . near_to_abs( value , tolerance ) \u00a7 A matcher that returns true when the actual value is approximately equal to value , specifically when std::abs(actual - expected) <= tolerance . Regular expression \u00a7 <mettle/matchers/regex.hpp> regex_match( ex [, syntax , match ]) \u00a7 A matcher that returns true if the regex ex matches the entirety of the actual value. If syntax or match are specified, the matcher uses those for the regex's syntax and match flags, respectively. regex_search( ex [, syntax , match ]) \u00a7 A matcher that returns true if the regex ex matches a subsequence of the actual value. If syntax or match are specified, the matcher uses those for the regex's syntax and match flags, respectively. Note Since std::regex objects don't provide access to a string representation of the expression, the ex parameter in the above matchers should be a string, not a regex. This allows the matcher to print the regex to the console if the matcher fails. Combinatoric \u00a7 <mettle/matchers/combinatoric.hpp> any( matchers... ) \u00a7 A matcher that returns true when any of its composed matchers are true. all( matchers... ) \u00a7 A matcher that returns true when all of its composed matchers are true. none( matchers... ) \u00a7 A matcher that returns true when none of its composed matchers are true. Collection \u00a7 <mettle/matchers/collection.hpp> member( matcher ) \u00a7 A matcher that returns true when an item in a collection matches the composed matcher. each( matcher ) \u00a7 A matcher that returns true when every item in a collection matches the composed matcher. each( range , meta_matcher ) \u00a7 A matcher that returns true when each item in a collection matches the corresponding item in range according to the matcher built from meta_matcher . range can be any iterable collection, including a std::initializer_list . This is roughly equivalent to: array( meta_matcher(range[0]), meta_matcher(range[1]), ... meta_matcher(range[n]) ) Warning When meta_matcher is a template function, be careful about how you pass it in. For instance, equal_to<int> will expect an rvalue-reference to an int . If range is an lvalue, you'll need to pass equal_to<const int &> instead. each( begin , end , meta_matcher ) \u00a7 A matcher that returns true when each item in a collection matches the corresponding item in the range [ begin , end ) according to the matcher built from meta_matcher . array( matchers... ) \u00a7 A matcher that returns true when the ith item in a collection matches the ith composed matcher, and the number of items in the collection is equal to the number of composed matchers. tuple( matchers... ) \u00a7 Similar to array , but applies to tuples instead (or anything else with a std::get<I>() overload). This matcher returns true when the ith item in a tuple matches the ith composed matcher. Since the size of a tuple can be determined at compile time, a length mismatch between the tuple and the number of composed matchers will cause a compiler error. sorted([ comparator ]) \u00a7 A matcher that returns true when the collection is sorted according to the binary predicate comparator (or the less-than operator if comparator isn't supplied). permutation( range [, predicate ]) \u00a7 A matcher that returns true if a permutation of range exists that equals the collection according for the binary predicate predicate (or the equality operator if predicate isn't supplied). permutation( begin , end [, predicate ]) \u00a7 A matcher that returns true if the range [ begin , end ) is a permutation of the collection for the binary predicate predicate (or the equality operator if predicate isn't supplied). Exception \u00a7 <mettle/matchers/exception.hpp> Exception matchers work a bit differently from other matchers. Since we can't catch an exception after the fact, we have to pass a function to our expectation instead: expect([]() { throw std::runtime_error(\"uh oh\"); }, thrown<std::runtime_error>(\"uh oh\")); thrown< Type >( what_matcher ) \u00a7 A matcher that returns true if an exception of type Type (or a subclass of Type ) is thrown and whose what() member function matches what_matcher . This is equivalent to thrown_raw<Type>(exception_what(what_matcher)) . thrown< Type >() \u00a7 A matcher that returns true if an exception of type Type (or a subclass of Type ) is thrown; equivalent to: thrown<Type>(anything()) . thrown() \u00a7 A matcher that returns true if an exception of any type Type is thrown. exception_what( what_matcher ) \u00a7 A matcher that returns true if the value is an exception whose what() member function matching what_matcher . thrown_raw< Type >( matcher ) \u00a7 A matcher that returns true if an exception of type Type (or a subclass of Type ) is thrown and whose value matches matcher . Death \u00a7 <mettle/matchers/death.hpp> Warning Because these matchers deal with process creation/termination, they can cause issues with software that relies on exit handlers (e.g. code coverage tools). In addition, these matchers are currently unsupported on Windows. Sorry about that! The most kvlt of all matchers, death matchers check that a function would cause the process to terminate, either by signalling or by exiting. (These matchers will fork a child process before calling the function so that the test framework doesn't terminate.) Like exception matchers , death matchers require a function to be passed to the expectation: expect([]() { abort(); }, killed(SIGABRT)); killed([ matcher ]) \u00a7 A matcher that returns true if the function terminated the process via a signal. If matcher is specified, killed will only return true if the signal that was raised matches matcher . exited([ matcher ]) \u00a7 A matcher that returns true if the function terminated the process by exiting (i.e. with exit , _exit , or _Exit ). If matcher is specified, exited will only return true if the exit status matches matcher .","title":"Built-in Matchers"},{"location":"built-in-matchers/#built-in-matchers","text":"Mettle comes with a set of general-purpose matchers that should cover the most common cases. We'll look at each of them below. The entire set of matchers can be included via #include <mettle/matchers.hpp> , or you can include just the categories you need by including the appropriate file (e.g. #include <mettle/matchers/combinatoric.hpp ).","title":"Built-in Matchers"},{"location":"built-in-matchers/#core","text":"<mettle/matchers/core.hpp>","title":"Core"},{"location":"built-in-matchers/#anything","text":"A matcher that always returns true . This is useful primarily as a placeholder, e.g. when you can't know for sure what an expected value is going to be, but you still want to test it.","title":"anything()"},{"location":"built-in-matchers/#is_notmatcher","text":"A matcher that negates another matcher.","title":"is_not(matcher)"},{"location":"built-in-matchers/#describematcher-desc","text":"A matcher that overrides the description of another matcher. desc is a string describing the resulting matcher. This can be useful for when the default description is unclear or overly-verbose.","title":"describe(matcher, desc)"},{"location":"built-in-matchers/#filterfunc-matcher-desc","text":"A matcher that filters the expected value through a function before passing it to another matcher. This helps when creating complex matchers that test multiple parts of a type, such as: all( filter([](auto &&x) { return x.first; }, equal_to(\"first\")), filter([](auto &&x) { return x.second; }, greater(0)) ); Additionally, you may pass in a string for desc , which will be added as a prefix to matcher 's description. This helps provide useful output explaining what exactly func is doing to the expected value.","title":"filter(func, matcher[, desc])"},{"location":"built-in-matchers/#relational","text":"<mettle/matchers/relational.hpp>","title":"Relational"},{"location":"built-in-matchers/#equal_tovalue","text":"A matcher that returns true when the actual value is equal to value according to the == operator. Note equal_to is also the implicit matcher . Any time a matcher takes another matcher as an argument, you can pass in a value, and it will be implicitly converted to equal_to(value) . This doesn't work for the root matcher; you need to explicitly say equal_to(value) in that case.","title":"equal_to(value)"},{"location":"built-in-matchers/#not_equal_tovalue","text":"A matcher that returns true when the actual value is not equal to value according to the != operator.","title":"not_equal_to(value)"},{"location":"built-in-matchers/#greatervalue","text":"A matcher that returns true when the actual value is greater than value according to the > operator.","title":"greater(value)"},{"location":"built-in-matchers/#greater_equalvalue","text":"A matcher that returns true when the actual value is greater than or equal to value according to the >= operator.","title":"greater_equal(value)"},{"location":"built-in-matchers/#lessvalue","text":"A matcher that returns true when the actual value is less than value according to the < operator.","title":"less(value)"},{"location":"built-in-matchers/#less_equalvalue","text":"A matcher that returns true when the actual value is less than or equal to value according to the <= operator.","title":"less_equal(value)"},{"location":"built-in-matchers/#arithmetic","text":"<mettle/matchers/arithmetic.hpp>","title":"Arithmetic"},{"location":"built-in-matchers/#near_tovalue-epsilon","text":"A matcher that returns true when the actual value is approximately equal to value , specifically when: auto mag = std::max<T>(std::abs(expected), std::abs(actual)); std::abs(actual - expected) <= mag * epsilon; If epsilon is not specified, it defaults to std::numeric_limits<T>::epsilon() * 10 . Warning As with most functions that check if two floating point numbers are approximately equal, this matcher will likely fail if one of the values is zero. In that case, use near_to_abs .","title":"near_to(value[, epsilon])"},{"location":"built-in-matchers/#near_to_absvalue-tolerance","text":"A matcher that returns true when the actual value is approximately equal to value , specifically when std::abs(actual - expected) <= tolerance .","title":"near_to_abs(value, tolerance)"},{"location":"built-in-matchers/#regular-expression","text":"<mettle/matchers/regex.hpp>","title":"Regular expression"},{"location":"built-in-matchers/#regex_matchex-syntax-match","text":"A matcher that returns true if the regex ex matches the entirety of the actual value. If syntax or match are specified, the matcher uses those for the regex's syntax and match flags, respectively.","title":"regex_match(ex[, syntax, match])"},{"location":"built-in-matchers/#regex_searchex-syntax-match","text":"A matcher that returns true if the regex ex matches a subsequence of the actual value. If syntax or match are specified, the matcher uses those for the regex's syntax and match flags, respectively. Note Since std::regex objects don't provide access to a string representation of the expression, the ex parameter in the above matchers should be a string, not a regex. This allows the matcher to print the regex to the console if the matcher fails.","title":"regex_search(ex[, syntax, match])"},{"location":"built-in-matchers/#combinatoric","text":"<mettle/matchers/combinatoric.hpp>","title":"Combinatoric"},{"location":"built-in-matchers/#anymatchers","text":"A matcher that returns true when any of its composed matchers are true.","title":"any(matchers...)"},{"location":"built-in-matchers/#allmatchers","text":"A matcher that returns true when all of its composed matchers are true.","title":"all(matchers...)"},{"location":"built-in-matchers/#nonematchers","text":"A matcher that returns true when none of its composed matchers are true.","title":"none(matchers...)"},{"location":"built-in-matchers/#collection","text":"<mettle/matchers/collection.hpp>","title":"Collection"},{"location":"built-in-matchers/#membermatcher","text":"A matcher that returns true when an item in a collection matches the composed matcher.","title":"member(matcher)"},{"location":"built-in-matchers/#eachmatcher","text":"A matcher that returns true when every item in a collection matches the composed matcher.","title":"each(matcher)"},{"location":"built-in-matchers/#eachrange-meta_matcher","text":"A matcher that returns true when each item in a collection matches the corresponding item in range according to the matcher built from meta_matcher . range can be any iterable collection, including a std::initializer_list . This is roughly equivalent to: array( meta_matcher(range[0]), meta_matcher(range[1]), ... meta_matcher(range[n]) ) Warning When meta_matcher is a template function, be careful about how you pass it in. For instance, equal_to<int> will expect an rvalue-reference to an int . If range is an lvalue, you'll need to pass equal_to<const int &> instead.","title":"each(range, meta_matcher)"},{"location":"built-in-matchers/#eachbegin-end-meta_matcher","text":"A matcher that returns true when each item in a collection matches the corresponding item in the range [ begin , end ) according to the matcher built from meta_matcher .","title":"each(begin, end, meta_matcher)"},{"location":"built-in-matchers/#arraymatchers","text":"A matcher that returns true when the ith item in a collection matches the ith composed matcher, and the number of items in the collection is equal to the number of composed matchers.","title":"array(matchers...)"},{"location":"built-in-matchers/#tuplematchers","text":"Similar to array , but applies to tuples instead (or anything else with a std::get<I>() overload). This matcher returns true when the ith item in a tuple matches the ith composed matcher. Since the size of a tuple can be determined at compile time, a length mismatch between the tuple and the number of composed matchers will cause a compiler error.","title":"tuple(matchers...)"},{"location":"built-in-matchers/#sortedcomparator","text":"A matcher that returns true when the collection is sorted according to the binary predicate comparator (or the less-than operator if comparator isn't supplied).","title":"sorted([comparator])"},{"location":"built-in-matchers/#permutationrange-predicate","text":"A matcher that returns true if a permutation of range exists that equals the collection according for the binary predicate predicate (or the equality operator if predicate isn't supplied).","title":"permutation(range[, predicate])"},{"location":"built-in-matchers/#permutationbegin-end-predicate","text":"A matcher that returns true if the range [ begin , end ) is a permutation of the collection for the binary predicate predicate (or the equality operator if predicate isn't supplied).","title":"permutation(begin, end[, predicate])"},{"location":"built-in-matchers/#exception","text":"<mettle/matchers/exception.hpp> Exception matchers work a bit differently from other matchers. Since we can't catch an exception after the fact, we have to pass a function to our expectation instead: expect([]() { throw std::runtime_error(\"uh oh\"); }, thrown<std::runtime_error>(\"uh oh\"));","title":"Exception"},{"location":"built-in-matchers/#throwntypewhat_matcher","text":"A matcher that returns true if an exception of type Type (or a subclass of Type ) is thrown and whose what() member function matches what_matcher . This is equivalent to thrown_raw<Type>(exception_what(what_matcher)) .","title":"thrown&lt;Type&gt;(what_matcher)"},{"location":"built-in-matchers/#throwntype","text":"A matcher that returns true if an exception of type Type (or a subclass of Type ) is thrown; equivalent to: thrown<Type>(anything()) .","title":"thrown&lt;Type&gt;()"},{"location":"built-in-matchers/#thrown","text":"A matcher that returns true if an exception of any type Type is thrown.","title":"thrown()"},{"location":"built-in-matchers/#exception_whatwhat_matcher","text":"A matcher that returns true if the value is an exception whose what() member function matching what_matcher .","title":"exception_what(what_matcher)"},{"location":"built-in-matchers/#thrown_rawtypematcher","text":"A matcher that returns true if an exception of type Type (or a subclass of Type ) is thrown and whose value matches matcher .","title":"thrown_raw&lt;Type&gt;(matcher)"},{"location":"built-in-matchers/#death","text":"<mettle/matchers/death.hpp> Warning Because these matchers deal with process creation/termination, they can cause issues with software that relies on exit handlers (e.g. code coverage tools). In addition, these matchers are currently unsupported on Windows. Sorry about that! The most kvlt of all matchers, death matchers check that a function would cause the process to terminate, either by signalling or by exiting. (These matchers will fork a child process before calling the function so that the test framework doesn't terminate.) Like exception matchers , death matchers require a function to be passed to the expectation: expect([]() { abort(); }, killed(SIGABRT));","title":"Death"},{"location":"built-in-matchers/#killedmatcher","text":"A matcher that returns true if the function terminated the process via a signal. If matcher is specified, killed will only return true if the signal that was raised matches matcher .","title":"killed([matcher])"},{"location":"built-in-matchers/#exitedmatcher","text":"A matcher that returns true if the function terminated the process by exiting (i.e. with exit , _exit , or _Exit ). If matcher is specified, exited will only return true if the exit status matches matcher .","title":"exited([matcher])"},{"location":"developer/","text":"Developer Guide \u00a7 If you're looking to learn about how mettle actually works, you've come to the right place! This developer guide will describe mettle's internals and how everything fits together. Runner \u00a7 mettle's structure is a bit different from other test frameworks. First, like some other test frameworks, individual (user-written) test files link to a shared library ( libmettle.so / mettle.dll ) to pull in common driver code. However, in addition, the mettle test driver can be used to aggregate the results of multiple test files. This lets you put your tests into multiple, separate binaries to reduce compilation time and allow different kinds of tests to be run all at once (e.g. normal unit tests and compilation-failure tests). Subprocesses \u00a7 When running tests, mettle makes extensive use of subprocesses to isolate tests as much as possible. First, the mettle driver creates a subprocess for each individual test binary, and these in turn (by default) create a subprocess for each test in the file. This ensures that no one test can crash the entire framework. However, the particulars differ between POSIX systems and Windows. POSIX \u00a7 When the individual test binary forks for a specific test, the test process is also set as the process group leader for a new process group. This ensures that any subprocesses it spawns can be killed after the main process finishes. Additionally, if tests are set to time out after a certain period, two more subprocesses are forked for each test: a monitor process and a timer process . The monitor process forks both the timer process and the actual test process and waits for the first one to finish. The timer process automatically exits after the timeout expires, and if it exits before the test process, the monitor process kills the test and sends a message that it timed out. You might be thinking, \"why not just use alarm(2) or setitimer(2) instead of forking two extra times?\" However, this would interact poorly with tests that rely on functions like sleep(3) . Hence, in the interest of maximum isolation of the test code, the timer is implemented as a subprocess. Likewise, running the timer in the parent process requires greater care when handling signals. In any case, the current method has the significant benefit of being entirely transparent to the parent process. Windows \u00a7 Since Windows is unable to fork a process, when the individual test binary creates a subprocess for a test, it simply reruns itself with a different set of command-line arguments, indicating that only a specific test should be run. This subprocess is immediately placed into a new job, ensuring that \u2013 like the POSIX version's process groups \u2013 any subprocesses it spawns can be killed after the main process finishes. Unlike the POSIX version, if tests are set to time out, we simply create a timer event and wait for it while we're waiting for the test process to end. If the timer's event fires first, we know to kill the test process. Since the timer is run in the parent process, this provides the same level of isolation as the POSIX version, but at the expense of some extra management; the parent process must now pay specific attention to the timer event instead of assuming that its child process will handle it. Suites \u00a7 When creating a test suite, the most important argument to pass is the creation function (conventionally a generic lambda). This function takes a suite_builder (or a subsuite_builder for subsuites). These are both template classes that let the user add tests or subsuites to the given suite. Once the creation function returns, the suite is compiled into a runnable_suite (subsuites, however, are merely compiled into an intermediary form and stored in its parent's (sub)suite_builder instance). When the parent is compiled, the subsuite and all of its tests are compiled as well, until it gets to the root suite, at which point all tests and subsuites are fully-compiled. If using the global suite or basic_suite types, once the suite is fully-compiled, it gets added to a global list of suites, held in detail::all_suites() (subsuites, however, are contained within their parents). This list is then used by the test driver to run all the tests.","title":"Developer Guide"},{"location":"developer/#developer-guide","text":"If you're looking to learn about how mettle actually works, you've come to the right place! This developer guide will describe mettle's internals and how everything fits together.","title":"Developer Guide"},{"location":"developer/#runner","text":"mettle's structure is a bit different from other test frameworks. First, like some other test frameworks, individual (user-written) test files link to a shared library ( libmettle.so / mettle.dll ) to pull in common driver code. However, in addition, the mettle test driver can be used to aggregate the results of multiple test files. This lets you put your tests into multiple, separate binaries to reduce compilation time and allow different kinds of tests to be run all at once (e.g. normal unit tests and compilation-failure tests).","title":"Runner"},{"location":"developer/#subprocesses","text":"When running tests, mettle makes extensive use of subprocesses to isolate tests as much as possible. First, the mettle driver creates a subprocess for each individual test binary, and these in turn (by default) create a subprocess for each test in the file. This ensures that no one test can crash the entire framework. However, the particulars differ between POSIX systems and Windows.","title":"Subprocesses"},{"location":"developer/#posix","text":"When the individual test binary forks for a specific test, the test process is also set as the process group leader for a new process group. This ensures that any subprocesses it spawns can be killed after the main process finishes. Additionally, if tests are set to time out after a certain period, two more subprocesses are forked for each test: a monitor process and a timer process . The monitor process forks both the timer process and the actual test process and waits for the first one to finish. The timer process automatically exits after the timeout expires, and if it exits before the test process, the monitor process kills the test and sends a message that it timed out. You might be thinking, \"why not just use alarm(2) or setitimer(2) instead of forking two extra times?\" However, this would interact poorly with tests that rely on functions like sleep(3) . Hence, in the interest of maximum isolation of the test code, the timer is implemented as a subprocess. Likewise, running the timer in the parent process requires greater care when handling signals. In any case, the current method has the significant benefit of being entirely transparent to the parent process.","title":"POSIX"},{"location":"developer/#windows","text":"Since Windows is unable to fork a process, when the individual test binary creates a subprocess for a test, it simply reruns itself with a different set of command-line arguments, indicating that only a specific test should be run. This subprocess is immediately placed into a new job, ensuring that \u2013 like the POSIX version's process groups \u2013 any subprocesses it spawns can be killed after the main process finishes. Unlike the POSIX version, if tests are set to time out, we simply create a timer event and wait for it while we're waiting for the test process to end. If the timer's event fires first, we know to kill the test process. Since the timer is run in the parent process, this provides the same level of isolation as the POSIX version, but at the expense of some extra management; the parent process must now pay specific attention to the timer event instead of assuming that its child process will handle it.","title":"Windows"},{"location":"developer/#suites","text":"When creating a test suite, the most important argument to pass is the creation function (conventionally a generic lambda). This function takes a suite_builder (or a subsuite_builder for subsuites). These are both template classes that let the user add tests or subsuites to the given suite. Once the creation function returns, the suite is compiled into a runnable_suite (subsuites, however, are merely compiled into an intermediary form and stored in its parent's (sub)suite_builder instance). When the parent is compiled, the subsuite and all of its tests are compiled as well, until it gets to the root suite, at which point all tests and subsuites are fully-compiled. If using the global suite or basic_suite types, once the suite is fully-compiled, it gets added to a global list of suites, held in detail::all_suites() (subsuites, however, are contained within their parents). This list is then used by the test driver to run all the tests.","title":"Suites"},{"location":"expectations/","text":"Expectations \u00a7 Expectations are a way of checking that the state of your code matches your expectation, similar to an assert . If the expectation is met, then everything proceeds as normal. Otherwise, it throws an exception and aborts the current test. Declaring an expectation \u00a7 Expectations are easy to write. Just call mettle::expect with the actual value you'd like to test and a matcher object. We'll look at matchers in detail later , but for now, let's just look at a simple matcher: mettle::equal_to(x) creates a matcher that will return true when the actual value passed to expect is equal to x (according to the definition of == for the type(s) in question). Here it is all put together: mettle::expect(the_beast, mettle::equal_to(666)); If this expectation failed, you'd see something like the following logged to your console (with the name of the failing test case preceding it): /path/to/test_file.cpp:13 expected: 666 actual: 123 Describing an expectation \u00a7 You can also provide an description for an expectation to make it easier to figure out what it was testing if you get a failure: mettle::expect(\"is 'to mega therion'?\", the_beast, mettle::equal_to(666)); If this expectation fails, you'll see a message like the previous failure, but with the description shown as well: is 'to mega therion'? (/path/to/test_file.cpp:13) expected: 666 actual: 123 Note Currently, only GCC supports getting the filename and line number automatically for an expectation. However, as compilers add support for std::experimental::source_location , mettle will automatically switch to showing these values. However, in the meantime you can use the METTLE_EXPECT macro in place of mettle::expect if you need to see the filename and line number. Printing objects \u00a7 In the examples above, the error output shows the expected and actual values. This is easy for simple types, like integers, but what about complex user-defined types? We could use the stream output operator << (and indeed, this option is supported), but there are times where you might want the debug output to be different from the normal output. In addition, not every type has (or should have) an overload of << . Instead, we use mettle::to_printable to ensure that our object will be displayed appropriately if we need to print it. This function returns an object (of unspecified type) that can be printed with the usual stream output operator. You can also pass an iterator pair to to_printable to print the entire range. Of course, feel free to overload to_printable for your own types to show whatever information you need to help debug test failures. Note Much like overloaded operators and standard library functions like std::swap , mettle uses argument-dependent lookup (ADL) to find the appropriate overload of to_printable . This is, of course, subject to all the usual concerns with ADL, so keep this in mind when using to_printable . What is a matcher? \u00a7 Above , we talked briefly about matchers and showed how to use the equality matcher: mettle::equal_to(666) . Before we continue any further, we should define what exactly a matcher is. Matchers are composable functions that let you declare what you expect a value to be. The composability of matchers allows you to build complex expections from a relatively small set of simple matchers. What's more, matchers automatically produce human-readable descriptions of what exactly they're testing, freeing you from having to manually describe every expectation! In addition, mettle comes with a collection of built-in matchers that can be used (or combined together) to perform most common tests. However, if these don't suffice, you can always write your own . How matchers work \u00a7 The internals of a matcher are actually pretty simple; they're just function objects inheriting from mettle::matcher_tag and also providing a desc() member function that returns a string describing the matcher. All matchers can be called with a single argument (the actual value in the expectation) and returns whether the match was successful or not. To illustrate this more concretely, the following defines a very simple matcher that checks if an int is 0: struct int_zero : matcher_tag { bool operator ()(int actual) const { return actual == 0; } std::string desc() const { return \"is 0\"; } }; Composing matchers \u00a7 Many of the built-in matchers, such as the combinatoric matchers , are higher-order matchers . That is, they are created by taking other matchers as arguments. This allows you to build more complex matchers that test multiple aspects of an object at once. For instance, you might want to check that a value is in the range [2, 4). With the all matcher, this is easy: using namespace mettle; expect(x, all(greater_equal(2), less(4))); Similarly, there are higher-order matchers that operate on collections , allowing you, for example, to test that all elements of a container meet a certain condition: using namespace mettle; expect(v, each(greater(0))); By composing matchers together, you can express all the expected state of an object in one place, making it clearer what exactly you're testing. Furthermore, since all matchers provide a description of what they match, these higher-order matchers can automatically tell you in human-readable form what they expect. For instance, our test to check if a value is between 2 and 4 above might print something like this if it fails: expected: all(>=2, <4) actual: 5 Mismatch messages \u00a7 As we saw above, for most simple expectations, a failure will cause the matcher's description to be printed out along with the actual value supplied to expect . However, for some matchers, just seeing the actual value isn't very useful. For example, with the thrown matchers, you already know that the actual value is a function, so printing that fact out doesn't help. Instead, matchers can choose to return a mismatch message that provides a morer useful, special-case description of the actual value (along with the usual bool to indicate if the matcher succeeded). For the thrown matcher, we can then return a description of the exception the function actually threw (if any). In this case, the matcher returns a mettle::match_result object (a bool and a std::string description) when called instead of a solitary bool . This makes the output for a failed test much nicer in this case: expected: threw std::runtime_error(what: \"bad\") actual: threw std::runtime_error(what: \"worse\") A match_result is implicity convertible to and from a bool , so matchers that return match_result s can easily be mixed with ones that return bool s. You can also use the ! operator to invert a match_result and preserve its message. Note Despite the name \"mismatch message\", it's useful to provide a message even on success, since a successful match can easily become a mismatch simply by using the is_not matcher.","title":"Expectations"},{"location":"expectations/#expectations","text":"Expectations are a way of checking that the state of your code matches your expectation, similar to an assert . If the expectation is met, then everything proceeds as normal. Otherwise, it throws an exception and aborts the current test.","title":"Expectations"},{"location":"expectations/#declaring-an-expectation","text":"Expectations are easy to write. Just call mettle::expect with the actual value you'd like to test and a matcher object. We'll look at matchers in detail later , but for now, let's just look at a simple matcher: mettle::equal_to(x) creates a matcher that will return true when the actual value passed to expect is equal to x (according to the definition of == for the type(s) in question). Here it is all put together: mettle::expect(the_beast, mettle::equal_to(666)); If this expectation failed, you'd see something like the following logged to your console (with the name of the failing test case preceding it): /path/to/test_file.cpp:13 expected: 666 actual: 123","title":"Declaring an expectation"},{"location":"expectations/#describing-an-expectation","text":"You can also provide an description for an expectation to make it easier to figure out what it was testing if you get a failure: mettle::expect(\"is 'to mega therion'?\", the_beast, mettle::equal_to(666)); If this expectation fails, you'll see a message like the previous failure, but with the description shown as well: is 'to mega therion'? (/path/to/test_file.cpp:13) expected: 666 actual: 123 Note Currently, only GCC supports getting the filename and line number automatically for an expectation. However, as compilers add support for std::experimental::source_location , mettle will automatically switch to showing these values. However, in the meantime you can use the METTLE_EXPECT macro in place of mettle::expect if you need to see the filename and line number.","title":"Describing an expectation"},{"location":"expectations/#printing-objects","text":"In the examples above, the error output shows the expected and actual values. This is easy for simple types, like integers, but what about complex user-defined types? We could use the stream output operator << (and indeed, this option is supported), but there are times where you might want the debug output to be different from the normal output. In addition, not every type has (or should have) an overload of << . Instead, we use mettle::to_printable to ensure that our object will be displayed appropriately if we need to print it. This function returns an object (of unspecified type) that can be printed with the usual stream output operator. You can also pass an iterator pair to to_printable to print the entire range. Of course, feel free to overload to_printable for your own types to show whatever information you need to help debug test failures. Note Much like overloaded operators and standard library functions like std::swap , mettle uses argument-dependent lookup (ADL) to find the appropriate overload of to_printable . This is, of course, subject to all the usual concerns with ADL, so keep this in mind when using to_printable .","title":"Printing objects"},{"location":"expectations/#what-is-a-matcher","text":"Above , we talked briefly about matchers and showed how to use the equality matcher: mettle::equal_to(666) . Before we continue any further, we should define what exactly a matcher is. Matchers are composable functions that let you declare what you expect a value to be. The composability of matchers allows you to build complex expections from a relatively small set of simple matchers. What's more, matchers automatically produce human-readable descriptions of what exactly they're testing, freeing you from having to manually describe every expectation! In addition, mettle comes with a collection of built-in matchers that can be used (or combined together) to perform most common tests. However, if these don't suffice, you can always write your own .","title":"What is a matcher?"},{"location":"expectations/#how-matchers-work","text":"The internals of a matcher are actually pretty simple; they're just function objects inheriting from mettle::matcher_tag and also providing a desc() member function that returns a string describing the matcher. All matchers can be called with a single argument (the actual value in the expectation) and returns whether the match was successful or not. To illustrate this more concretely, the following defines a very simple matcher that checks if an int is 0: struct int_zero : matcher_tag { bool operator ()(int actual) const { return actual == 0; } std::string desc() const { return \"is 0\"; } };","title":"How matchers work"},{"location":"expectations/#composing-matchers","text":"Many of the built-in matchers, such as the combinatoric matchers , are higher-order matchers . That is, they are created by taking other matchers as arguments. This allows you to build more complex matchers that test multiple aspects of an object at once. For instance, you might want to check that a value is in the range [2, 4). With the all matcher, this is easy: using namespace mettle; expect(x, all(greater_equal(2), less(4))); Similarly, there are higher-order matchers that operate on collections , allowing you, for example, to test that all elements of a container meet a certain condition: using namespace mettle; expect(v, each(greater(0))); By composing matchers together, you can express all the expected state of an object in one place, making it clearer what exactly you're testing. Furthermore, since all matchers provide a description of what they match, these higher-order matchers can automatically tell you in human-readable form what they expect. For instance, our test to check if a value is between 2 and 4 above might print something like this if it fails: expected: all(>=2, <4) actual: 5","title":"Composing matchers"},{"location":"expectations/#mismatch-messages","text":"As we saw above, for most simple expectations, a failure will cause the matcher's description to be printed out along with the actual value supplied to expect . However, for some matchers, just seeing the actual value isn't very useful. For example, with the thrown matchers, you already know that the actual value is a function, so printing that fact out doesn't help. Instead, matchers can choose to return a mismatch message that provides a morer useful, special-case description of the actual value (along with the usual bool to indicate if the matcher succeeded). For the thrown matcher, we can then return a description of the exception the function actually threw (if any). In this case, the matcher returns a mettle::match_result object (a bool and a std::string description) when called instead of a solitary bool . This makes the output for a failed test much nicer in this case: expected: threw std::runtime_error(what: \"bad\") actual: threw std::runtime_error(what: \"worse\") A match_result is implicity convertible to and from a bool , so matchers that return match_result s can easily be mixed with ones that return bool s. You can also use the ! operator to invert a match_result and preserve its message. Note Despite the name \"mismatch message\", it's useful to provide a message even on success, since a successful match can easily become a mismatch simply by using the is_not matcher.","title":"Mismatch messages"},{"location":"install/","text":"Installation \u00a7 Broadly, mettle is composed of three parts: a set of header files, a shared library ( libmettle.so or mettle.dll ), and a universal test driver ( mettle ). Before we can start using mettle, we'll need to build and install it. Just show me what to type! \u00a7 Here are the necessary commands to build and install mettle, assuming you already have Boost and a C++17 compiler (we'll discuss all of these parts in more detail below): pip install bfg9000 cd path/to/mettle 9k build/ --vendorize cd build/ ninja install Note If you already have bencode.hpp installed, you can remove --vendorize from the above commands. Dependencies \u00a7 Before you get started with mettle, you'll need to install its dependencies: A C++17-compliant compiler Clang 7.0+ GCC 7.2+ MSVC 2017+ Boost 1.55+ bencode.hpp bfg9000 To simplify the installation of bencode.hpp, you can pass --vendorize during configuration (or run scripts/vendorize_bencode.py directly). This will download and copy bencode.hpp to mettle's include directory, so you won't have to install it yourself. Note If you plan to use libc++, this Gist should help you build Boost to link to it. Header-only version \u00a7 If you don't want to install all of the above dependencies and build the binaries for mettle, you can use this library in a header-only mode by using the following instead of the usual #include <mettle.hpp> : #include <mettle/header_only.hpp> However, the header-only version is quite limited and doesn't support any of the command-line arguments described in Running Tests . Building and installing \u00a7 Once you've installed all of mettle's dependencies, you can build mettle itself! To build mettle, you'll first need to install bfg9000 . The snippets below assume you're using the Ninja backend for bfg9000, but you can replace this with any other build system bfg supports. Building with bfg9000 is straightforward. Just run the following: cd path/to/mettle/ 9k build/ --vendorize cd build/ ninja install As noted above, if you already have bencode.hpp installed, you can remove the --vendorize argument. If you'd like to build with C++17 support, you can pass --std=c++17 during configuration. You can specify the compiler to use and its options with the usual (Unix-style) environment variables, such as CXX and CXXFLAGS . For further information about how to use bfg9000, such as changing the build backend, see its documentation . Testing mettle \u00a7 Mettle's own tests are written entirely in mettle. (It wouldn't be a very good test framework otherwise!) To build and run all the tests, just call the following from the build directory: ninja test If you'd rather build the tests without running them, you can call ninja tests . In that case, you can execute the tests as described later in Running Tests . Building the examples \u00a7 mettle comes with a series of examples to help show how to construct different kinds of tests. Similar to the above, you can build all of these with ninja examples . Building the documentation \u00a7 mettle uses MkDocs for its documentation. To build the documentation, first install MkDocs, and then run ninja doc-build . You can also run ninja doc-serve to run a test webserver with a preview of the documentation.","title":"Installation"},{"location":"install/#installation","text":"Broadly, mettle is composed of three parts: a set of header files, a shared library ( libmettle.so or mettle.dll ), and a universal test driver ( mettle ). Before we can start using mettle, we'll need to build and install it.","title":"Installation"},{"location":"install/#just-show-me-what-to-type","text":"Here are the necessary commands to build and install mettle, assuming you already have Boost and a C++17 compiler (we'll discuss all of these parts in more detail below): pip install bfg9000 cd path/to/mettle 9k build/ --vendorize cd build/ ninja install Note If you already have bencode.hpp installed, you can remove --vendorize from the above commands.","title":"Just show me what to type!"},{"location":"install/#dependencies","text":"Before you get started with mettle, you'll need to install its dependencies: A C++17-compliant compiler Clang 7.0+ GCC 7.2+ MSVC 2017+ Boost 1.55+ bencode.hpp bfg9000 To simplify the installation of bencode.hpp, you can pass --vendorize during configuration (or run scripts/vendorize_bencode.py directly). This will download and copy bencode.hpp to mettle's include directory, so you won't have to install it yourself. Note If you plan to use libc++, this Gist should help you build Boost to link to it.","title":"Dependencies"},{"location":"install/#header-only-version","text":"If you don't want to install all of the above dependencies and build the binaries for mettle, you can use this library in a header-only mode by using the following instead of the usual #include <mettle.hpp> : #include <mettle/header_only.hpp> However, the header-only version is quite limited and doesn't support any of the command-line arguments described in Running Tests .","title":"Header-only version"},{"location":"install/#building-and-installing","text":"Once you've installed all of mettle's dependencies, you can build mettle itself! To build mettle, you'll first need to install bfg9000 . The snippets below assume you're using the Ninja backend for bfg9000, but you can replace this with any other build system bfg supports. Building with bfg9000 is straightforward. Just run the following: cd path/to/mettle/ 9k build/ --vendorize cd build/ ninja install As noted above, if you already have bencode.hpp installed, you can remove the --vendorize argument. If you'd like to build with C++17 support, you can pass --std=c++17 during configuration. You can specify the compiler to use and its options with the usual (Unix-style) environment variables, such as CXX and CXXFLAGS . For further information about how to use bfg9000, such as changing the build backend, see its documentation .","title":"Building and installing"},{"location":"install/#testing-mettle","text":"Mettle's own tests are written entirely in mettle. (It wouldn't be a very good test framework otherwise!) To build and run all the tests, just call the following from the build directory: ninja test If you'd rather build the tests without running them, you can call ninja tests . In that case, you can execute the tests as described later in Running Tests .","title":"Testing mettle"},{"location":"install/#building-the-examples","text":"mettle comes with a series of examples to help show how to construct different kinds of tests. Similar to the above, you can build all of these with ninja examples .","title":"Building the examples"},{"location":"install/#building-the-documentation","text":"mettle uses MkDocs for its documentation. To build the documentation, first install MkDocs, and then run ninja doc-build . You can also run ninja doc-serve to run a test webserver with a preview of the documentation.","title":"Building the documentation"},{"location":"running-tests/","text":"Running Tests \u00a7 Once you've built an executable test (if you haven't built one, be sure to read the tutorial first), you'll find that there are a bunch of options for running it. There are two main ways to run a test executable. Running the test executable directly \u00a7 For small projects, you may have only a single test executable. In this case, you can simply run the file directly: $ ./test_my_code Below , we'll see a list of the options we can pass to the text executable, letting you tailor the output or how the tests are run. Using the mettle universal test driver \u00a7 For testing larger projects, it's generally recommended to divide your test suites into multiple .cpp files and compile them into separate binaries. This allows you to improve build times and to better isolate tests from each other. When doing so, you can use the mettle executable to run all of your individual binaries at once. The interface is much like that of the individual binaries, and all of the command-line options above work with the mettle executable as well. To specify which of the test binaries to run, just pass their filenames to mettle : $ mettle test_file1 test_file2 Like the individual test executables, the mettle driver accepts several options to modify its behavior and output. Forwarding arguments \u00a7 You can also pass along arguments to a test binary by quoting the binary: $ mettle test_file1 \"caliber test_foo.cpp test_bar.cpp\" This executes test_file1 and then executes caliber with two arguments: test_foo.cpp and test_bar.cpp . You can also pass wildcards (globs) inside quoted arguments: $ mettle test_file1 \"caliber test_*.cpp\" Command-line options \u00a7 Generic options \u00a7 --help ( -h ) \u00a7 Show help and usage information. Driver options \u00a7 --timeout N ( -t ) \u00a7 Time out and fail any tests that take longer than N milliseconds to execute. Warning --no-subproc can't be specified while using this option. --test REGEX ( -T ) \u00a7 Filter the tests that will be run to those matching a regex. If --test is specified multiple times, tests that match any of the regexes will be run. --attr ATTR [= VALUE ],... ( -a ) \u00a7 Filter the tests that will be run based on the tests' attributes . Tests matching each of the attributes (and, optionally, values) will be run by the test driver. If --attr is specified multiple times, tests that match any of the filters will be run. You can also prepend ATTR with ! to negate that test. Let's look at some examples to get a better sense of how this works: --attr slow Run only tests with the attribute slow . --attr protocol=http Run only tests with the attribute protocol having a value of http . --attr '!slow' Run only tests without the attribute slow . (Note the use of quotation marks, since many shells treat ! as a special character.) --attr '!protocol=http' Run only tests without the attribute protocol , or which have protocol set to something other than http . --attr slow,protocol=http Run only tests that match both attributes. --attr slow --attr protocol=http Run tests that match either attribute. --no-subproc \u00a7 By default, mettle creates a subprocess for each test, in order to detect crashes during the execution of a test. To disable this, you can pass --no-subproc , and all the tests will run in the same process. This option can only be specified for the individual test binaries, not for the mettle driver. Output options \u00a7 --output FORMAT ( -o ) \u00a7 Set the output format for the test results. If --output isn't passed, the format is set to brief . The available formats are: silent : Don't show any output during the test run; only a summary after the fact will be shown. counter : Show a single line per run counting up the total number of passed, failed, and skipped tests. brief : A single character for each test will be shown. . means a passed test, ! a failed test, and _ a skipped test. verbose : Show the full name of tests and suites as they're being run. xunit : Log the test results in xUnit format to the file specified by --file . --color [ WHEN ] ( -c ) \u00a7 Print test results in color. This is good if your terminal supports colors, since it makes the results much easier to read! WHEN can be one of always (the default if you don't explicitly specify WHEN ), never , or auto . --runs N ( -n ) \u00a7 Run the tests a total of N times. This is useful for catching intermittent failures. At the end, the summary will show the output of each failure for every test. --show-terminal \u00a7 Show the terminal output (stdout and stderr) of each test after it finishes. To enable this, --no-subproc can't be specified (if --no-subproc is specified, the terminal output will just appear in-line with the tests). --show-time \u00a7 Show the duration (in milliseconds) of each test as it runs, as well as the total time of the entire job. --file [ FILE ] \u00a7 The file to print test results to; only applies to the xunit output format . Defaults to mettle.xml .","title":"Running Tests"},{"location":"running-tests/#running-tests","text":"Once you've built an executable test (if you haven't built one, be sure to read the tutorial first), you'll find that there are a bunch of options for running it. There are two main ways to run a test executable.","title":"Running Tests"},{"location":"running-tests/#running-the-test-executable-directly","text":"For small projects, you may have only a single test executable. In this case, you can simply run the file directly: $ ./test_my_code Below , we'll see a list of the options we can pass to the text executable, letting you tailor the output or how the tests are run.","title":"Running the test executable directly"},{"location":"running-tests/#using-the-mettle-universal-test-driver","text":"For testing larger projects, it's generally recommended to divide your test suites into multiple .cpp files and compile them into separate binaries. This allows you to improve build times and to better isolate tests from each other. When doing so, you can use the mettle executable to run all of your individual binaries at once. The interface is much like that of the individual binaries, and all of the command-line options above work with the mettle executable as well. To specify which of the test binaries to run, just pass their filenames to mettle : $ mettle test_file1 test_file2 Like the individual test executables, the mettle driver accepts several options to modify its behavior and output.","title":"Using the mettle universal test driver"},{"location":"running-tests/#forwarding-arguments","text":"You can also pass along arguments to a test binary by quoting the binary: $ mettle test_file1 \"caliber test_foo.cpp test_bar.cpp\" This executes test_file1 and then executes caliber with two arguments: test_foo.cpp and test_bar.cpp . You can also pass wildcards (globs) inside quoted arguments: $ mettle test_file1 \"caliber test_*.cpp\"","title":"Forwarding arguments"},{"location":"running-tests/#command-line-options","text":"","title":"Command-line options"},{"location":"running-tests/#generic-options","text":"","title":"Generic options"},{"location":"running-tests/#help-option","text":"Show help and usage information.","title":"--help (-h)"},{"location":"running-tests/#driver-options","text":"","title":"Driver options"},{"location":"running-tests/#timeout-option","text":"Time out and fail any tests that take longer than N milliseconds to execute. Warning --no-subproc can't be specified while using this option.","title":"--timeout N (-t)"},{"location":"running-tests/#test-option","text":"Filter the tests that will be run to those matching a regex. If --test is specified multiple times, tests that match any of the regexes will be run.","title":"--test REGEX (-T)"},{"location":"running-tests/#attr-option","text":"Filter the tests that will be run based on the tests' attributes . Tests matching each of the attributes (and, optionally, values) will be run by the test driver. If --attr is specified multiple times, tests that match any of the filters will be run. You can also prepend ATTR with ! to negate that test. Let's look at some examples to get a better sense of how this works: --attr slow Run only tests with the attribute slow . --attr protocol=http Run only tests with the attribute protocol having a value of http . --attr '!slow' Run only tests without the attribute slow . (Note the use of quotation marks, since many shells treat ! as a special character.) --attr '!protocol=http' Run only tests without the attribute protocol , or which have protocol set to something other than http . --attr slow,protocol=http Run only tests that match both attributes. --attr slow --attr protocol=http Run tests that match either attribute.","title":"--attr ATTR[=VALUE],... (-a)"},{"location":"running-tests/#no-subproc-option","text":"By default, mettle creates a subprocess for each test, in order to detect crashes during the execution of a test. To disable this, you can pass --no-subproc , and all the tests will run in the same process. This option can only be specified for the individual test binaries, not for the mettle driver.","title":"--no-subproc"},{"location":"running-tests/#output-options","text":"","title":"Output options"},{"location":"running-tests/#output-option","text":"Set the output format for the test results. If --output isn't passed, the format is set to brief . The available formats are: silent : Don't show any output during the test run; only a summary after the fact will be shown. counter : Show a single line per run counting up the total number of passed, failed, and skipped tests. brief : A single character for each test will be shown. . means a passed test, ! a failed test, and _ a skipped test. verbose : Show the full name of tests and suites as they're being run. xunit : Log the test results in xUnit format to the file specified by --file .","title":"--output FORMAT (-o)"},{"location":"running-tests/#color-option","text":"Print test results in color. This is good if your terminal supports colors, since it makes the results much easier to read! WHEN can be one of always (the default if you don't explicitly specify WHEN ), never , or auto .","title":"--color [WHEN] (-c)"},{"location":"running-tests/#runs-option","text":"Run the tests a total of N times. This is useful for catching intermittent failures. At the end, the summary will show the output of each failure for every test.","title":"--runs N (-n)"},{"location":"running-tests/#show-terminal-option","text":"Show the terminal output (stdout and stderr) of each test after it finishes. To enable this, --no-subproc can't be specified (if --no-subproc is specified, the terminal output will just appear in-line with the tests).","title":"--show-terminal"},{"location":"running-tests/#show-time-option","text":"Show the duration (in milliseconds) of each test as it runs, as well as the total time of the entire job.","title":"--show-time"},{"location":"running-tests/#file-option","text":"The file to print test results to; only applies to the xunit output format . Defaults to mettle.xml .","title":"--file [FILE]"},{"location":"tutorial/","text":"Tutorial \u00a7 So, you want to write some unit tests? This tutorial will walk you through the steps needed to write, build, and run a simple test. Your first test \u00a7 Let's get started by taking a look at the test file we used when running tests . We'll discuss each part in detail below: #include <mettle.hpp> using namespace mettle; suite<> first(\"my first suite\", [](auto &_) { _.test(\"my first test\", []() { expect(true, equal_to(true)); }); }); Dissecting the test file \u00a7 First up, the obvious: we #include <mettle.hpp> , which imports all the code we need to build and run simple tests: test suites, matchers, and a test runner. With that out of the way, we can start defining our tests. All tests are grouped into suites. Suites are created as global variables with the type mettle::suite<> , and take a string name and a callback function (typically a lambda). The callback lets us define our tests for the suite. It takes a single argument, a reference to a mettle::suite_builder<mettle::expectation_failure> , but since that's pretty long, we conventionally just say auto & and use a generic lambda instead: suite<> first(\"my first suite\", [](auto &_) { /* ... */ }); Note There are lots of other options you can pass to the suite's constructor, like fixtures or test attributes , but we'll get to those later. With the suite defined, now we just need to write our tests and add them via the suite builder. Like suites, tests have both a string name and a callback function, but this time the callback is the code to run when the test executes: _.test(\"my first test\", []() { /* ... */ }); Inside our test function, we need to write some test code: expect(true, equal_to(true)); This is an expectation . We'll discuss them in more detail later , but in short, they define the things we actually want to test in our tests. This expectation makes sure that true is equal to true . If it's not, the test will alert us to the fact so we can fix it (hopefully before the universe finishes crashing down around us). Building the test \u00a7 Building a test is straightforward. Since mettle provides its own test runner with a main() function, the above source code is all you need for a fully-operational test. Just compile the test like so: $ clang++ -std=c++17 -o test_first test_first.cpp -lmettle Remember, mettle is a C++17 library, so you'll likely need to tell the compiler to use C++17 mode (or C++1z mode for slightly older compilers). Running the test \u00a7 Once you've built the test, you just need to run the binary and observe the results. In this case, the results will look like: $ ./test_first . 1/1 test passed The single dot ( . ) shows that our one and only test passed, which the summary confirms. However, if the unthinkable has happened and our test fails, we'd see something like this instead: $ ./test_first ! 0/1 tests passed my first suite > my first test FAILED expected: true actual: false Here, we see an exclamation point ( ! ) instead of a dot, to indicate a failed test. At the end of the output, the details of the failure are shown. With this information, we can hopefully diagnose the failure and fix the bug. There are many more options that can be supplied to the test binary to alter its output or how it runs tests. To learn more about those, see Running Tests .","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"So, you want to write some unit tests? This tutorial will walk you through the steps needed to write, build, and run a simple test.","title":"Tutorial"},{"location":"tutorial/#your-first-test","text":"Let's get started by taking a look at the test file we used when running tests . We'll discuss each part in detail below: #include <mettle.hpp> using namespace mettle; suite<> first(\"my first suite\", [](auto &_) { _.test(\"my first test\", []() { expect(true, equal_to(true)); }); });","title":"Your first test"},{"location":"tutorial/#dissecting-the-test-file","text":"First up, the obvious: we #include <mettle.hpp> , which imports all the code we need to build and run simple tests: test suites, matchers, and a test runner. With that out of the way, we can start defining our tests. All tests are grouped into suites. Suites are created as global variables with the type mettle::suite<> , and take a string name and a callback function (typically a lambda). The callback lets us define our tests for the suite. It takes a single argument, a reference to a mettle::suite_builder<mettle::expectation_failure> , but since that's pretty long, we conventionally just say auto & and use a generic lambda instead: suite<> first(\"my first suite\", [](auto &_) { /* ... */ }); Note There are lots of other options you can pass to the suite's constructor, like fixtures or test attributes , but we'll get to those later. With the suite defined, now we just need to write our tests and add them via the suite builder. Like suites, tests have both a string name and a callback function, but this time the callback is the code to run when the test executes: _.test(\"my first test\", []() { /* ... */ }); Inside our test function, we need to write some test code: expect(true, equal_to(true)); This is an expectation . We'll discuss them in more detail later , but in short, they define the things we actually want to test in our tests. This expectation makes sure that true is equal to true . If it's not, the test will alert us to the fact so we can fix it (hopefully before the universe finishes crashing down around us).","title":"Dissecting the test file"},{"location":"tutorial/#building-the-test","text":"Building a test is straightforward. Since mettle provides its own test runner with a main() function, the above source code is all you need for a fully-operational test. Just compile the test like so: $ clang++ -std=c++17 -o test_first test_first.cpp -lmettle Remember, mettle is a C++17 library, so you'll likely need to tell the compiler to use C++17 mode (or C++1z mode for slightly older compilers).","title":"Building the test"},{"location":"tutorial/#running-the-test","text":"Once you've built the test, you just need to run the binary and observe the results. In this case, the results will look like: $ ./test_first . 1/1 test passed The single dot ( . ) shows that our one and only test passed, which the summary confirms. However, if the unthinkable has happened and our test fails, we'd see something like this instead: $ ./test_first ! 0/1 tests passed my first suite > my first test FAILED expected: true actual: false Here, we see an exclamation point ( ! ) instead of a dot, to indicate a failed test. At the end of the output, the details of the failure are shown. With this information, we can hopefully diagnose the failure and fix the bug. There are many more options that can be supplied to the test binary to alter its output or how it runs tests. To learn more about those, see Running Tests .","title":"Running the test"},{"location":"writing-matchers/","text":"Writing Your Own Matchers \u00a7 mettle is designed to make it easy to write your own matchers to complement the built-in suite of matchers. This makes it easier to test the state of objects with complex properties. Once created, user-defined matchers can be composed as normal with built-in matchers as you'd expect. Helper \u00a7 basic_matcher( function , desc ) \u00a7 The easiest way to create your own matcher is with the basic_matcher class. This takes two parameters: first, a function object that accepts a value of any type, and returns a bool (with true naturally meaning a successful match); and second, a string describing the matcher. This form of basic_matcher creates a basic_matcher<void, F> , where F is the type of the function. For instance, here's a simple matcher that returns true when the actual value is 4: auto match_four() { return basic_matcher([](const auto &value) -> bool { return value == 4; }, \"== 4\"); } basic_matcher( capture , function , prefix , [ suffix ]) \u00a7 You can also capture a value to use with your matcher; while you certainly can capture the value via a lambda, passing the variable directly to basic_matcher allows it to be printed automatically when desc() is called. In this version, function works as above, except that it takes a second argument for the captured object. The final arguments, prefix and suffix , are string that will be prepended (or appended) to the printed form of capture . This form of basic_matcher returns a basic_matcher<T, F> , where T is the type of the capture and F is the type of the function. Here's an example of a matcher that returns true when two numbers are off by one: template<typename T> auto off_by_one(T &&expected) { return basic_matcher( std::forward<T>(expected), [](const auto &actual, const auto &expected) -> bool { auto x = std::minmax<T>(actual, expected); return x.second - x.first == 1; }, \"off by 1 from \" ); } ensure_matcher( thing ) \u00a7 Sometimes, a matcher should be able to accept other matchers as an argument. However, we also typically want to be able to pass in arbitrary objects as a shorthand to implicitly call the equal_to matcher. In this case, we'd use ensure_matcher . ensure_matcher wraps an object with the equal_to matcher, or returns the passed-in matcher if the object is already a matcher. As an example, let's create a matcher that returns true if exactly one of its arguments is true : template<typename T> auto either(T &&a, T &&b) { auto a_matcher = ensure_matcher(std::forward<T>(a)); auto b_matcher = ensure_matcher(std::forward<T>(b)); return basic_matcher([a_matcher, b_matcher](const auto &value) -> bool { return a_matcher(value) ^ b_matcher(value); }, a_matcher.desc() + \" xor \" + b_matcher.desc()); } Starting from scratch \u00a7 For particularly complex matchers, basic_matcher may not provide much value. In these cases, you can instead build your own matcher from scratch. First, and most importantly, all matchers must inherit from matcher_tag . This removes any ambiguity between actual matchers and types that just have a similar interface. As the previous section hints at, a matcher must also have a const overloaded operator () that takes a value of any type and returns a bool , and a const desc function that returns a string description of the matcher. A matcher made from scratch isn't much more complex than one made using the helper functions above; most of the complexity will come from the behaviors you define. Here's a simple example that never returns true : struct nothing : matcher_tag { template<typename T> bool operator ()(const U &value) const { return false; } std::string desc() const { return \"nothing\"; } }; Further examples \u00a7 Naturally, many more examples of matchers can be found in mettle's own source code . Feel free to consult these to get some ideas for how to implement your own matchers!","title":"Writing Your Own Matchers"},{"location":"writing-matchers/#writing-your-own-matchers","text":"mettle is designed to make it easy to write your own matchers to complement the built-in suite of matchers. This makes it easier to test the state of objects with complex properties. Once created, user-defined matchers can be composed as normal with built-in matchers as you'd expect.","title":"Writing Your Own Matchers"},{"location":"writing-matchers/#helper","text":"","title":"Helper"},{"location":"writing-matchers/#basic_matcherfunction-desc","text":"The easiest way to create your own matcher is with the basic_matcher class. This takes two parameters: first, a function object that accepts a value of any type, and returns a bool (with true naturally meaning a successful match); and second, a string describing the matcher. This form of basic_matcher creates a basic_matcher<void, F> , where F is the type of the function. For instance, here's a simple matcher that returns true when the actual value is 4: auto match_four() { return basic_matcher([](const auto &value) -> bool { return value == 4; }, \"== 4\"); }","title":"basic_matcher(function, desc)"},{"location":"writing-matchers/#basic_matchercapture-function-prefix-suffix","text":"You can also capture a value to use with your matcher; while you certainly can capture the value via a lambda, passing the variable directly to basic_matcher allows it to be printed automatically when desc() is called. In this version, function works as above, except that it takes a second argument for the captured object. The final arguments, prefix and suffix , are string that will be prepended (or appended) to the printed form of capture . This form of basic_matcher returns a basic_matcher<T, F> , where T is the type of the capture and F is the type of the function. Here's an example of a matcher that returns true when two numbers are off by one: template<typename T> auto off_by_one(T &&expected) { return basic_matcher( std::forward<T>(expected), [](const auto &actual, const auto &expected) -> bool { auto x = std::minmax<T>(actual, expected); return x.second - x.first == 1; }, \"off by 1 from \" ); }","title":"basic_matcher(capture, function, prefix, [suffix])"},{"location":"writing-matchers/#ensure_matcherthing","text":"Sometimes, a matcher should be able to accept other matchers as an argument. However, we also typically want to be able to pass in arbitrary objects as a shorthand to implicitly call the equal_to matcher. In this case, we'd use ensure_matcher . ensure_matcher wraps an object with the equal_to matcher, or returns the passed-in matcher if the object is already a matcher. As an example, let's create a matcher that returns true if exactly one of its arguments is true : template<typename T> auto either(T &&a, T &&b) { auto a_matcher = ensure_matcher(std::forward<T>(a)); auto b_matcher = ensure_matcher(std::forward<T>(b)); return basic_matcher([a_matcher, b_matcher](const auto &value) -> bool { return a_matcher(value) ^ b_matcher(value); }, a_matcher.desc() + \" xor \" + b_matcher.desc()); }","title":"ensure_matcher(thing)"},{"location":"writing-matchers/#starting-from-scratch","text":"For particularly complex matchers, basic_matcher may not provide much value. In these cases, you can instead build your own matcher from scratch. First, and most importantly, all matchers must inherit from matcher_tag . This removes any ambiguity between actual matchers and types that just have a similar interface. As the previous section hints at, a matcher must also have a const overloaded operator () that takes a value of any type and returns a bool , and a const desc function that returns a string description of the matcher. A matcher made from scratch isn't much more complex than one made using the helper functions above; most of the complexity will come from the behaviors you define. Here's a simple example that never returns true : struct nothing : matcher_tag { template<typename T> bool operator ()(const U &value) const { return false; } std::string desc() const { return \"nothing\"; } };","title":"Starting from scratch"},{"location":"writing-matchers/#further-examples","text":"Naturally, many more examples of matchers can be found in mettle's own source code . Feel free to consult these to get some ideas for how to implement your own matchers!","title":"Further examples"},{"location":"writing-tests/","text":"Writing Tests \u00a7 Below, we'll look at how test files are structured, how to create the tests themselves, and how to group them together to perform higher-level operations on them. Throughout this page, we'll assume that the following appears at the beginning of our examples: #include <mettle.hpp> This includes all the headers necessary to use mettle. Alternately, you can #include <mettle/header_only.hpp> if you prefer to use mettle without compiling libmettle.so and the mettle universal driver. If you'd rather include a smaller subset of headers, e.g. to improve compilation speeds, you'll need the following to define tests and suites: #include <mettle/suite.hpp> // Choose only one of these: #include <mettle/driver/lib_driver.hpp> // The driver to go with libmettle.so #include <mettle/driver/header_driver.hpp> // The header-only driver Defining suites \u00a7 In mettle, all tests are grouped by suites. Suites are generally defined as global variables (we'll see more ways to define suites later), and take two arguments in the constructor: a string name, and a callback function taking a reference to a mettle::suite_builder<mettle::expectation_failure> . Generally, we just define the callback as a generic lambda: mettle::suite<> my_suite(\"my suite\", [](auto &_) { /* ... */ }); If you don't plan to use mettle's expectations for checking program state, you can replace mettle::suite<> with mettle::basic_suite<my_exception> to create a test suite using your own exception type as the \"canonical\" exception. Tests \u00a7 While we have a suite now, we still need to define some tests. Tests are, without a doubt, the most important part of a test suite. We define our tests inside our suite's callback function, using the suite_builder passed into it. Like our suite, each test takes two arguments: a string name, and a callback function defining the test. However, the test's callback takes no arguments: mettle::suite<> my_suite(\"my suite\", [](auto &_) { _.test(\"my test\", []() { /* ... */ }); }); Inside the test's callback function, we can write our actual test. If our code throws an exception, the test will fail; otherwise, it passes. Most of your tests should use expectations (similar to assertions) to perform the actual tests. Expectations provide informative error messages if any part of your test fails. Setup and teardown \u00a7 Sometimes, you'll have a bunch of tests that all have the same setup and teardown code. Test fixtures let you do this (mostly) automatically. If a test suite has a setup or teardown function set, they'll run before (or after) each test in the suite: mettle::suite<> with_setup(\"my suite\", [](auto &_) { _.setup([]() { /* ... */ }); _.teardown([]() { /* ... */ }); _.test(\"my test\", []() { /* ... */ }); }); Note For symmetry with third-party test types, you can also express _.test(...) as mettle::test(_, ...) . The same applies to _.setup(...) and _.teardown(...) . Subsuites \u00a7 When testing something particularly complex, you might find it useful to group test suites together. You can do this by creating a subsuite inside a parent suite: mettle::suite<> with_subsuites(\"suite with subsuites\", [](auto &_) { _.subsuite(\"subsuite\", [](auto &_) { _.test(\"my subtest\", []() { /* ... */ }); }); }); You might have noticed above that, unlike for the root suite, our subsuite doesn't contain an empty template parameter list (read: there's no <> ). Since subsuite is just a member function, the angle brackets aren't necessary, but what if you want to supply a fixture for your subsuite? That's where it gets a bit more complex. As you may recall, our suite's callback uses a generic lambda, and so _ is a dependent type . Template member functions of a dependent type must be prefixed with the template keyword, like so: _.template subsuite<int>(\"subsuite\", [](auto &_) { /* ... */ }); However, this is rather ugly. To eliminate the template keyword, we could either redefine our lambda to no longer be generic, or just use the mettle::subsuite helper: mettle::subsuite<>(_, \"subsuite\", [](auto &_) { /* ... */ }); Nested setup and teardown \u00a7 As you might imagine, a test in a subsuite uses not only the subsuite's setup and teardown functions, but inherits the parent suite's as well (and so on up the tree). When executing a test in a subsuite, the test runner will walk down the suite hierarchy, calling each setup function in turn before running the test. After finishing the test, it will walk back up the tree calling each teardown function. For a two-level hierarchy, this is what would happen for each test in the subsuite: Call the parent suite's setup function (if defined). Call the subsuite's setup function (if defined). Run the test function Call the subsuite's teardown function (if defined). Call the parent suite's teardown function (if defined). Fixtures \u00a7 Setup and teardown functions are of limited use without fixtures. Fixtures allow you to safely write multiple, independent tests that test the same object. Each test gets its own instance of the fixture, preventing it from affecting any of the other tests. A fixture's lifetime is as follows: Constructor the fixture using the default constructor. Pass the fixture by reference to the setup function (if defined). Pass the fixture by reference to the test function. Pass the fixture by reference to the teardown function (if defined). Destruct the fixture. Declaring a fixture is simple. Just pass the type of your fixture in the template parameters of your mettle::suite object: struct my_fixture { int i; }; mettle::suite<my_fixture> with_fixture(\"suite with a fixture\", [](auto &_) { _.setup([](my_fixture &f) { f.i = 1; }); _.test(\"test my fixture\", [](my_fixture &f) { mettle::expect(f.i, equal_to(1)); }); }); Astute readers will notice that a test fixture could easily be used to replace the setup and teardown functions by using RAII. However, both options are supported, since it's often simpler to write a setup/teardown code than to write a less-flexible helper class. For instance, your fixture might be a database object from your production code that you want to add some test records to for testing. Rather than wrapping the database in a helper, you can just add the test records in setup . Sometimes, the default constructor for a fixture isn't appropriate. In these cases, you can use fixture factories , discussed below. Nested fixtures \u00a7 Like the nested setup and teardown functions, test fixtures are also inherited in subsuites. This allows a parent suite to handle common fixtures for a bunch of subsuites, reducing code duplication: mettle::suite<int> nested_fixtures(\"suite with subsuites\", [](auto &_) { _.setup([](int &i) { i = 1; }); _.test(\"my parent test\", [](int &i) { mettle::expect(i, equal_to(1)); }); mettle::subsuite<std::string>(_, \"subsuite\", [](auto &_) { _.setup([](int &i, std::string &s) { i++; s = \"foo\"; }); _.test(\"my subtest\", [](int &i, std::string &s) { mettle::expect(i, equal_to(2)); mettle::expect(s, equal_to(\"foo\")); }); }); }); As you can see above, subsuites inherit their parents' fixtures, much like they inherit their parents' setup and teardown functions. Fixture factories \u00a7 Sometimes, a fixture can't be constructed as is, e.g if the fixture isn't default-constructible. In these cases, you can use a fixture factory to create your fixture object with any parameters you like. For simple cases, we can use mettle::bind_factory , which takes a list of arguments and constructs an object of your fixture's type with those arguments: mettle::suite<int> bound_fixture(\"using bind_factory\", mettle::bind_factory(3), [](auto &_) { _.test([](int &i) { mettle::expect(i, equal_to(3)); }); }); For more complex fixtures, you can create your own factories from scratch. A fixture factory is simply an object with a templated make<T>() function: struct my_factory { template<typename T> T make() { return T(12); } }; mettle::suite<my_fixture> with_factory(\"suite\", my_factory{}, [](auto &_) { /* ... */ }); In fact, even \"ordinary\" fixtures use their own factory: auto_factory . The following code snippets are equivalent: mettle::suite<my_fixture> without_auto_factory(\"suite\", [](auto &_) { /* ... */ }); mettle::suite<my_fixture> with_auto_factory(\"suite\", mettle::auto_factory, [](auto &_) { /* ... */ }); Later, we'll learn more about fixture factories and how to transform their types. Parameterizing tests \u00a7 While suites are a good way to group your tests together, sometimes you want to run the same tests on several different types of objects. In this case, all you need to do is specify multiple fixtures when defining a test suite. The example below creates two test suites, one with a fixture of int and one with a fixture of float : mettle::suite<int, float> param_test(\"parameterized suite\", [](auto &_) { _.test(\"my test\", [](auto &fixture) { /* ... */ }); }); This works just the same for subsuites as well: mettle::suite<> param_sub_test(\"parameterized subsuites\", [](auto &_) { mettle::subsuite<int, float>(_, \"parameterized suite 1\", [](auto &_) { /* ... */ }); _.template subsuite<int, float>(_, \"parameterized suite 2\", [](auto &_) { /* ... */ }); }); One subtle difference you may have noticed is that now, our test definitions use a generic lambda: [](auto &fixture) { /* ... */ } . As you might imagine, this allows the test function to accept a fixture of either an int or a float and to do the usual thing when a template is instantiated. Of course, you don't always need to use auto here; if all of your fixtures inherit from a common base type, you can use an ordinary lambda that takes a reference to the base type. Transforming fixture types \u00a7 Earlier, we learned about fixture factories . We can do even more with them, though: a fixture factory's make<T>() can actually return any type (including void !), not just T . This can be useful for more complex tests, like testing a container type with several different element types: struct vector_factory { template<typename T> std::vector<T> make() { return {}; } }; mettle::suite<int, float> vector_suite(\"suite\", vector_factory{}, [](auto &_) { _.test(\"empty()\", [](auto &vec) { mettle::expect(vec.empty(), equal_to(true)); }); }); Type-only fixtures \u00a7 As mentioned above, a fixture factory's make<T>() can return void . In this case, the suite has no fixture whatsoever. This is primarily useful when you want to parameterize on a list of types, but you don't want to automatically instantiate the fixture object. The built-in fixture factory type_only handles this for you. In particular, note the parameter-less test function: mettle::suite<int, float> type_only(\"suite\", mettle::type_only, [](auto &_) { _.test(\"empty()\", []() { /* ... */ }); }); Getting the parameterized type \u00a7 In some cases, you may want to know the parameterized type, e.g. if you'd like to create your own instances of the object. You can retrieve this via the fixture_type trait (or the fixture_type_t alias) like so: mettle::suite<int, float> param_type(\"suite\", mettle::type_only, [](auto &_) { using Fixture = mettle::fixture_type_t<decltype(_)>; _.test(\"my test\", []() { /* use Fixture here */ }); }); Test attributes \u00a7 For large projects with many tests, it can be useful to run only a subset of them, instead of the entire collection. While splitting up tests by file can help, it doesn't allow for very precise control of what tests get run. Instead, you can apply attributes to your tests (or whole suites!) and filter on them. The skip attribute \u00a7 mettle provides one built-in attribute: mettle::skip . As the name implies, this attribute causes a test to be skipped by default. This can be useful when a test is broken, since the test runner will keep track of the skipped tests as a reminder that you need to go back and fix the test. You can also provide a comment for the skipped test that will be shown in the test logs explaining why it was skipped. For more information about how to use the skip attribute, see Using Attributes below. Defining attributes \u00a7 In addition to the built-in skip attribute, you can define your own attributes. There are three basic kinds of attributes, differentiated by the number of values each can hold: mettle::bool_attr , which holds 0 or 1 values; mettle::string_attr , which holds exactly 1 value; and mettle::list_attr , which holds 1 or more distinct values. bool_attr s are somewhat special and can be given a default action when they're encountered (either mettle::attr_action::run or mettle::attr_action::skip ). As you might be able to guess, the predefined skip attribute is just a bool_attr whose action is attr_action::skip . To define an attribute, you just need to create a global instance of one of the aforementioned attribute kinds: mettle::bool_attr slow(\"slow\"); mettle::bool_attr busted(\"busted\", attr_action::skip); mettle::list_attr tags(\"tags\"); Using attributes \u00a7 It's easy to apply attributes to your tests: simply create instances of each kind of attribute you want, and pass them to the test creation function immediately after the test name: _.test(\"my test\", {mettle::skip, slow(\"takes too long\"), tags(\"cat\", \"goat\")}, [](auto &fixture) { /* ... */ }); This creates a mettle::attributes object that gets stored alongside the test. As you might notice, bool_attrs can be implicitly converted to an attribute instance, but other types require you to call them to list their values. Suite attributes \u00a7 Like tests, whole suites can have attributes associated with them; these are applied the same way as for tests, and the list of attributes will automatically be inherited by any children (tests or subsuites). The children can set their own attributes, and all the attributes in the hierarchy will be combined together for each test. For bool_attr s and string_attr s, children with the same attribute as their parents will override the parent's attribute, but for list_attr s, the values from the parent and child will be merged: mettle::suite<> attr_suite(\"my suite\", {mettle::skip(\"broken\"), tags(\"cat\")}, [](auto &_) { _.test(\"my test\", {slow, mettle::skip(\"fixme\"), tags(\"dog\")}, []() { /* This test has the following attributes: slow, skip(\"fixme\"), and tags(\"cat\", \"dog\"). */ }); }); Mixing fixture factories and attributes \u00a7 At this point, you may be wondering how to specify both a fixture factory and a set of attributes for suite. Since they're both optional arguments that appear between the suite's name and its creation function, which goes first? The attributes always go first : mettle::suite<int> the_works(\"my complicated suite\", {mettle::skip}, type_only, [](auto &_) { /* ... */ }); There's an easy rule to remember this: since attributes are a way of identifying the suite, they go near the other identifier: the name. Likewise, fixture factories affect how the suite is executed , so they go near the creation function, which also affects its execution.","title":"Writing Tests"},{"location":"writing-tests/#writing-tests","text":"Below, we'll look at how test files are structured, how to create the tests themselves, and how to group them together to perform higher-level operations on them. Throughout this page, we'll assume that the following appears at the beginning of our examples: #include <mettle.hpp> This includes all the headers necessary to use mettle. Alternately, you can #include <mettle/header_only.hpp> if you prefer to use mettle without compiling libmettle.so and the mettle universal driver. If you'd rather include a smaller subset of headers, e.g. to improve compilation speeds, you'll need the following to define tests and suites: #include <mettle/suite.hpp> // Choose only one of these: #include <mettle/driver/lib_driver.hpp> // The driver to go with libmettle.so #include <mettle/driver/header_driver.hpp> // The header-only driver","title":"Writing Tests"},{"location":"writing-tests/#defining-suites","text":"In mettle, all tests are grouped by suites. Suites are generally defined as global variables (we'll see more ways to define suites later), and take two arguments in the constructor: a string name, and a callback function taking a reference to a mettle::suite_builder<mettle::expectation_failure> . Generally, we just define the callback as a generic lambda: mettle::suite<> my_suite(\"my suite\", [](auto &_) { /* ... */ }); If you don't plan to use mettle's expectations for checking program state, you can replace mettle::suite<> with mettle::basic_suite<my_exception> to create a test suite using your own exception type as the \"canonical\" exception.","title":"Defining suites"},{"location":"writing-tests/#tests","text":"While we have a suite now, we still need to define some tests. Tests are, without a doubt, the most important part of a test suite. We define our tests inside our suite's callback function, using the suite_builder passed into it. Like our suite, each test takes two arguments: a string name, and a callback function defining the test. However, the test's callback takes no arguments: mettle::suite<> my_suite(\"my suite\", [](auto &_) { _.test(\"my test\", []() { /* ... */ }); }); Inside the test's callback function, we can write our actual test. If our code throws an exception, the test will fail; otherwise, it passes. Most of your tests should use expectations (similar to assertions) to perform the actual tests. Expectations provide informative error messages if any part of your test fails.","title":"Tests"},{"location":"writing-tests/#setup-and-teardown","text":"Sometimes, you'll have a bunch of tests that all have the same setup and teardown code. Test fixtures let you do this (mostly) automatically. If a test suite has a setup or teardown function set, they'll run before (or after) each test in the suite: mettle::suite<> with_setup(\"my suite\", [](auto &_) { _.setup([]() { /* ... */ }); _.teardown([]() { /* ... */ }); _.test(\"my test\", []() { /* ... */ }); }); Note For symmetry with third-party test types, you can also express _.test(...) as mettle::test(_, ...) . The same applies to _.setup(...) and _.teardown(...) .","title":"Setup and teardown"},{"location":"writing-tests/#subsuites","text":"When testing something particularly complex, you might find it useful to group test suites together. You can do this by creating a subsuite inside a parent suite: mettle::suite<> with_subsuites(\"suite with subsuites\", [](auto &_) { _.subsuite(\"subsuite\", [](auto &_) { _.test(\"my subtest\", []() { /* ... */ }); }); }); You might have noticed above that, unlike for the root suite, our subsuite doesn't contain an empty template parameter list (read: there's no <> ). Since subsuite is just a member function, the angle brackets aren't necessary, but what if you want to supply a fixture for your subsuite? That's where it gets a bit more complex. As you may recall, our suite's callback uses a generic lambda, and so _ is a dependent type . Template member functions of a dependent type must be prefixed with the template keyword, like so: _.template subsuite<int>(\"subsuite\", [](auto &_) { /* ... */ }); However, this is rather ugly. To eliminate the template keyword, we could either redefine our lambda to no longer be generic, or just use the mettle::subsuite helper: mettle::subsuite<>(_, \"subsuite\", [](auto &_) { /* ... */ });","title":"Subsuites"},{"location":"writing-tests/#nested-setup-and-teardown","text":"As you might imagine, a test in a subsuite uses not only the subsuite's setup and teardown functions, but inherits the parent suite's as well (and so on up the tree). When executing a test in a subsuite, the test runner will walk down the suite hierarchy, calling each setup function in turn before running the test. After finishing the test, it will walk back up the tree calling each teardown function. For a two-level hierarchy, this is what would happen for each test in the subsuite: Call the parent suite's setup function (if defined). Call the subsuite's setup function (if defined). Run the test function Call the subsuite's teardown function (if defined). Call the parent suite's teardown function (if defined).","title":"Nested setup and teardown"},{"location":"writing-tests/#fixtures","text":"Setup and teardown functions are of limited use without fixtures. Fixtures allow you to safely write multiple, independent tests that test the same object. Each test gets its own instance of the fixture, preventing it from affecting any of the other tests. A fixture's lifetime is as follows: Constructor the fixture using the default constructor. Pass the fixture by reference to the setup function (if defined). Pass the fixture by reference to the test function. Pass the fixture by reference to the teardown function (if defined). Destruct the fixture. Declaring a fixture is simple. Just pass the type of your fixture in the template parameters of your mettle::suite object: struct my_fixture { int i; }; mettle::suite<my_fixture> with_fixture(\"suite with a fixture\", [](auto &_) { _.setup([](my_fixture &f) { f.i = 1; }); _.test(\"test my fixture\", [](my_fixture &f) { mettle::expect(f.i, equal_to(1)); }); }); Astute readers will notice that a test fixture could easily be used to replace the setup and teardown functions by using RAII. However, both options are supported, since it's often simpler to write a setup/teardown code than to write a less-flexible helper class. For instance, your fixture might be a database object from your production code that you want to add some test records to for testing. Rather than wrapping the database in a helper, you can just add the test records in setup . Sometimes, the default constructor for a fixture isn't appropriate. In these cases, you can use fixture factories , discussed below.","title":"Fixtures"},{"location":"writing-tests/#nested-fixtures","text":"Like the nested setup and teardown functions, test fixtures are also inherited in subsuites. This allows a parent suite to handle common fixtures for a bunch of subsuites, reducing code duplication: mettle::suite<int> nested_fixtures(\"suite with subsuites\", [](auto &_) { _.setup([](int &i) { i = 1; }); _.test(\"my parent test\", [](int &i) { mettle::expect(i, equal_to(1)); }); mettle::subsuite<std::string>(_, \"subsuite\", [](auto &_) { _.setup([](int &i, std::string &s) { i++; s = \"foo\"; }); _.test(\"my subtest\", [](int &i, std::string &s) { mettle::expect(i, equal_to(2)); mettle::expect(s, equal_to(\"foo\")); }); }); }); As you can see above, subsuites inherit their parents' fixtures, much like they inherit their parents' setup and teardown functions.","title":"Nested fixtures"},{"location":"writing-tests/#fixture-factories","text":"Sometimes, a fixture can't be constructed as is, e.g if the fixture isn't default-constructible. In these cases, you can use a fixture factory to create your fixture object with any parameters you like. For simple cases, we can use mettle::bind_factory , which takes a list of arguments and constructs an object of your fixture's type with those arguments: mettle::suite<int> bound_fixture(\"using bind_factory\", mettle::bind_factory(3), [](auto &_) { _.test([](int &i) { mettle::expect(i, equal_to(3)); }); }); For more complex fixtures, you can create your own factories from scratch. A fixture factory is simply an object with a templated make<T>() function: struct my_factory { template<typename T> T make() { return T(12); } }; mettle::suite<my_fixture> with_factory(\"suite\", my_factory{}, [](auto &_) { /* ... */ }); In fact, even \"ordinary\" fixtures use their own factory: auto_factory . The following code snippets are equivalent: mettle::suite<my_fixture> without_auto_factory(\"suite\", [](auto &_) { /* ... */ }); mettle::suite<my_fixture> with_auto_factory(\"suite\", mettle::auto_factory, [](auto &_) { /* ... */ }); Later, we'll learn more about fixture factories and how to transform their types.","title":"Fixture factories"},{"location":"writing-tests/#parameterizing-tests","text":"While suites are a good way to group your tests together, sometimes you want to run the same tests on several different types of objects. In this case, all you need to do is specify multiple fixtures when defining a test suite. The example below creates two test suites, one with a fixture of int and one with a fixture of float : mettle::suite<int, float> param_test(\"parameterized suite\", [](auto &_) { _.test(\"my test\", [](auto &fixture) { /* ... */ }); }); This works just the same for subsuites as well: mettle::suite<> param_sub_test(\"parameterized subsuites\", [](auto &_) { mettle::subsuite<int, float>(_, \"parameterized suite 1\", [](auto &_) { /* ... */ }); _.template subsuite<int, float>(_, \"parameterized suite 2\", [](auto &_) { /* ... */ }); }); One subtle difference you may have noticed is that now, our test definitions use a generic lambda: [](auto &fixture) { /* ... */ } . As you might imagine, this allows the test function to accept a fixture of either an int or a float and to do the usual thing when a template is instantiated. Of course, you don't always need to use auto here; if all of your fixtures inherit from a common base type, you can use an ordinary lambda that takes a reference to the base type.","title":"Parameterizing tests"},{"location":"writing-tests/#transforming-fixture-types","text":"Earlier, we learned about fixture factories . We can do even more with them, though: a fixture factory's make<T>() can actually return any type (including void !), not just T . This can be useful for more complex tests, like testing a container type with several different element types: struct vector_factory { template<typename T> std::vector<T> make() { return {}; } }; mettle::suite<int, float> vector_suite(\"suite\", vector_factory{}, [](auto &_) { _.test(\"empty()\", [](auto &vec) { mettle::expect(vec.empty(), equal_to(true)); }); });","title":"Transforming fixture types"},{"location":"writing-tests/#type-only-fixtures","text":"As mentioned above, a fixture factory's make<T>() can return void . In this case, the suite has no fixture whatsoever. This is primarily useful when you want to parameterize on a list of types, but you don't want to automatically instantiate the fixture object. The built-in fixture factory type_only handles this for you. In particular, note the parameter-less test function: mettle::suite<int, float> type_only(\"suite\", mettle::type_only, [](auto &_) { _.test(\"empty()\", []() { /* ... */ }); });","title":"Type-only fixtures"},{"location":"writing-tests/#getting-the-parameterized-type","text":"In some cases, you may want to know the parameterized type, e.g. if you'd like to create your own instances of the object. You can retrieve this via the fixture_type trait (or the fixture_type_t alias) like so: mettle::suite<int, float> param_type(\"suite\", mettle::type_only, [](auto &_) { using Fixture = mettle::fixture_type_t<decltype(_)>; _.test(\"my test\", []() { /* use Fixture here */ }); });","title":"Getting the parameterized type"},{"location":"writing-tests/#test-attributes","text":"For large projects with many tests, it can be useful to run only a subset of them, instead of the entire collection. While splitting up tests by file can help, it doesn't allow for very precise control of what tests get run. Instead, you can apply attributes to your tests (or whole suites!) and filter on them.","title":"Test attributes"},{"location":"writing-tests/#the-skip-attribute","text":"mettle provides one built-in attribute: mettle::skip . As the name implies, this attribute causes a test to be skipped by default. This can be useful when a test is broken, since the test runner will keep track of the skipped tests as a reminder that you need to go back and fix the test. You can also provide a comment for the skipped test that will be shown in the test logs explaining why it was skipped. For more information about how to use the skip attribute, see Using Attributes below.","title":"The skip attribute"},{"location":"writing-tests/#defining-attributes","text":"In addition to the built-in skip attribute, you can define your own attributes. There are three basic kinds of attributes, differentiated by the number of values each can hold: mettle::bool_attr , which holds 0 or 1 values; mettle::string_attr , which holds exactly 1 value; and mettle::list_attr , which holds 1 or more distinct values. bool_attr s are somewhat special and can be given a default action when they're encountered (either mettle::attr_action::run or mettle::attr_action::skip ). As you might be able to guess, the predefined skip attribute is just a bool_attr whose action is attr_action::skip . To define an attribute, you just need to create a global instance of one of the aforementioned attribute kinds: mettle::bool_attr slow(\"slow\"); mettle::bool_attr busted(\"busted\", attr_action::skip); mettle::list_attr tags(\"tags\");","title":"Defining attributes"},{"location":"writing-tests/#using-attributes","text":"It's easy to apply attributes to your tests: simply create instances of each kind of attribute you want, and pass them to the test creation function immediately after the test name: _.test(\"my test\", {mettle::skip, slow(\"takes too long\"), tags(\"cat\", \"goat\")}, [](auto &fixture) { /* ... */ }); This creates a mettle::attributes object that gets stored alongside the test. As you might notice, bool_attrs can be implicitly converted to an attribute instance, but other types require you to call them to list their values.","title":"Using attributes"},{"location":"writing-tests/#suite-attributes","text":"Like tests, whole suites can have attributes associated with them; these are applied the same way as for tests, and the list of attributes will automatically be inherited by any children (tests or subsuites). The children can set their own attributes, and all the attributes in the hierarchy will be combined together for each test. For bool_attr s and string_attr s, children with the same attribute as their parents will override the parent's attribute, but for list_attr s, the values from the parent and child will be merged: mettle::suite<> attr_suite(\"my suite\", {mettle::skip(\"broken\"), tags(\"cat\")}, [](auto &_) { _.test(\"my test\", {slow, mettle::skip(\"fixme\"), tags(\"dog\")}, []() { /* This test has the following attributes: slow, skip(\"fixme\"), and tags(\"cat\", \"dog\"). */ }); });","title":"Suite attributes"},{"location":"writing-tests/#mixing-fixture-factories-and-attributes","text":"At this point, you may be wondering how to specify both a fixture factory and a set of attributes for suite. Since they're both optional arguments that appear between the suite's name and its creation function, which goes first? The attributes always go first : mettle::suite<int> the_works(\"my complicated suite\", {mettle::skip}, type_only, [](auto &_) { /* ... */ }); There's an easy rule to remember this: since attributes are a way of identifying the suite, they go near the other identifier: the name. Likewise, fixture factories affect how the suite is executed , so they go near the creation function, which also affects its execution.","title":"Mixing fixture factories and attributes"},{"location":"about/changes/","text":"Changes \u00a7 v0.2 \u00a7 in progress New features \u00a7 Interleave skipped and failed tests in their original order in the summary log Capturing large arrays of trivial types for matchers is now much faster expect now takes a universal reference for the value to test to support matchers which need access to non-const objects (e.g. to call a non-const member function) New matcher exception_what() Bug fixes \u00a7 Test failures across multiple runs are now correctly groups in the summary results bencode.hpp is now installed alongside mettle when --vendorize is used Arithmetic matchers now use ADL to find max and abs , allowing custom arithmetic types to use their own implementations of these functions Breaking changes \u00a7 Implementation updated to require C++17 make_matcher helper has been removed; use basic_matcher directly instead v0.1 \u00a7 2019-11-29 Initial release Support for defining assertions via composable matchers Tests can be groups into suites/subsuites, which can additionally be parameterized by type or value Allow aggregating the output of multiple test executables via the mettle driver","title":"Changes"},{"location":"about/changes/#changes","text":"","title":"Changes"},{"location":"about/changes/#v02","text":"in progress","title":"v0.2"},{"location":"about/changes/#new-features","text":"Interleave skipped and failed tests in their original order in the summary log Capturing large arrays of trivial types for matchers is now much faster expect now takes a universal reference for the value to test to support matchers which need access to non-const objects (e.g. to call a non-const member function) New matcher exception_what()","title":"New features"},{"location":"about/changes/#bug-fixes","text":"Test failures across multiple runs are now correctly groups in the summary results bencode.hpp is now installed alongside mettle when --vendorize is used Arithmetic matchers now use ADL to find max and abs , allowing custom arithmetic types to use their own implementations of these functions","title":"Bug fixes"},{"location":"about/changes/#breaking-changes","text":"Implementation updated to require C++17 make_matcher helper has been removed; use basic_matcher directly instead","title":"Breaking changes"},{"location":"about/changes/#v01","text":"2019-11-29 Initial release Support for defining assertions via composable matchers Tests can be groups into suites/subsuites, which can additionally be parameterized by type or value Allow aggregating the output of multiple test executables via the mettle driver","title":"v0.1"},{"location":"about/license/","text":"License \u00a7 BSD 3-clause license \u00a7 Copyright (c) 2014-2023, Jim Porter All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"about/license/#license","text":"","title":"License"},{"location":"about/license/#bsd-3-clause-license","text":"Copyright (c) 2014-2023, Jim Porter All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"BSD 3-clause license"}]}