{
    "docs": [
        {
            "location": "/", 
            "text": "mettle\n\n\nmettle\n is a \"batteries included\" unit testing framework for C++14. Its\nmission is to provide a full toolbox to address your testing needs and to look\ngood doing it.\n\n\nFeatures\n\n\n\n\nBuild your own assertions\n\n\nExpectations (assertions) are defined using composable matchers that\nautomatically generate human-readable output, ensuring even complex objects are\neasy to test.\n\n\nNest your tests\n\n\nSuites group your tests together and can be nested as deeply as you need,\nso you can use their hierarchy to set up and tear down your fixtures for you.\n\n\nDon't repeat yourself\n\n\nType- and value-parameterized tests let you write your tests once and apply them\nto multiple implementations or preconditions.\n\n\nAggregate everything\n\n\nThe \nmettle\n universal test runner makes it a snap to write multiple,\nindependent test files \u2013 even ones running completely different kinds of tests \u2013\nand aggregate them into a single list of results.\n\n\n\n\nA brief example\n\n\nA picture is worth a thousand words, and code's almost as good (I'm sure it's\nworth at least 100 words), so let's take a look at a test file:\n\n\n#include \nmettle.hpp\n\nusing namespace mettle;\n\nsuite\n basic(\na basic suite\n, [](auto \n_) {\n\n  _.test(\na test\n, []() {\n    expect(true, equal_to(true));\n  });\n\n  for(int i = 0; i \n 4; i++) {\n    _.test(\ntest number \n + std::to_string(i), [i]() {\n      expect(i % 2, less(2));\n    });\n  }\n\n  subsuite\n(_, \na subsuite\n, [](auto \n_) {\n    _.test(\na sub-test\n, []() {\n      expect(true, equal_to(true));\n    });\n  });\n\n});\n\n\n\n\nFor further examples, please see the\n\nexamples/\n\nsubdirectory.", 
            "title": "Home"
        }, 
        {
            "location": "/#mettle", 
            "text": "mettle  is a \"batteries included\" unit testing framework for C++14. Its\nmission is to provide a full toolbox to address your testing needs and to look\ngood doing it.", 
            "title": "mettle"
        }, 
        {
            "location": "/#features", 
            "text": "", 
            "title": "Features"
        }, 
        {
            "location": "/#build-your-own-assertions", 
            "text": "Expectations (assertions) are defined using composable matchers that\nautomatically generate human-readable output, ensuring even complex objects are\neasy to test.", 
            "title": "Build your own assertions"
        }, 
        {
            "location": "/#nest-your-tests", 
            "text": "Suites group your tests together and can be nested as deeply as you need,\nso you can use their hierarchy to set up and tear down your fixtures for you.", 
            "title": "Nest your tests"
        }, 
        {
            "location": "/#dont-repeat-yourself", 
            "text": "Type- and value-parameterized tests let you write your tests once and apply them\nto multiple implementations or preconditions.", 
            "title": "Don't repeat yourself"
        }, 
        {
            "location": "/#aggregate-everything", 
            "text": "The  mettle  universal test runner makes it a snap to write multiple,\nindependent test files \u2013 even ones running completely different kinds of tests \u2013\nand aggregate them into a single list of results.", 
            "title": "Aggregate everything"
        }, 
        {
            "location": "/#a-brief-example", 
            "text": "A picture is worth a thousand words, and code's almost as good (I'm sure it's\nworth at least 100 words), so let's take a look at a test file:  #include  mettle.hpp \nusing namespace mettle;\n\nsuite  basic( a basic suite , [](auto  _) {\n\n  _.test( a test , []() {\n    expect(true, equal_to(true));\n  });\n\n  for(int i = 0; i   4; i++) {\n    _.test( test number   + std::to_string(i), [i]() {\n      expect(i % 2, less(2));\n    });\n  }\n\n  subsuite (_,  a subsuite , [](auto  _) {\n    _.test( a sub-test , []() {\n      expect(true, equal_to(true));\n    });\n  });\n\n});  For further examples, please see the examples/ \nsubdirectory.", 
            "title": "A brief example"
        }, 
        {
            "location": "/install/", 
            "text": "Installation\n\n\nBroadly, mettle is composed of three parts: a set of header files, a shared\nlibrary (\nlibmettle.so\n or \nmettle.dll\n), and a universal test driver\n(\nmettle\n). Before we can start using mettle, we'll need to build and install\nit.\n\n\nDependencies\n\n\nBefore you get started with mettle, you'll need to install its dependencies:\n\n\n\n\nA C++14-compliant compiler (for generic lambdas and various standard library\n  features)\n\n\nclang\n + \nlibc++\n 3.6+\n\n\nGCC\n + \nlibstdc++\n\n   5.1+\n\n\nMSVC\n 2015+\n\n\n\n\n\n\nBoost\n 1.55+\n\n\nbencode.hpp\n\n\nbfg9000\n\n\n\n\n\n\nNote\n\n\nIf you plan to use libc++, \nthis\nGist\n should help you\nbuild Boost to link to it.\n\n\n\n\nHeader-only version\n\n\nIf you don't want to install all of the above dependencies and build the\nbinaries for mettle, you can use this library in a header-only mode by using\nthe following instead of the usual \n#include \nmettle.hpp\n:\n\n\n#include \nmettle/header_only.hpp\n\n\n\n\n\nHowever, the header-only version is quite limited and doesn't support any of the\ncommand-line arguments described in \nRunning Tests\n. In\naddition, if you don't have Boost installed, you'll need a standard library that\nincludes \nstd::experimental::string_view\n.\n\n\nBuilding and installing\n\n\nOnce you've installed all of mettle's dependencies, you can build mettle itself!\nTo build mettle, you'll first need to install\n\nbfg9000\n. The snippets below assume you're\nusing the \nNinja\n backend for bfg9000, but you can\nreplace this with any other build system bfg supports.\n\n\nBuilding with bfg9000 is straightforward. Just run the following:\n\n\n$ bfg9000 /path/to/mettle build\n$ cd build\n$ ninja install\n\n\n\n\nYou can specify the compiler to use and its options with the usual (Unix-style)\nenvironment variables, such as \nCXX\n and \nCXXFLAGS\n. For further information\nabout how to use bfg9000, such as changing the build backend, see its\n\ndocumentation\n.\n\n\nTesting mettle\n\n\nMettle's own tests are written entirely in mettle. (It wouldn't be a very good\ntest framework otherwise!) To build and run all the tests, just call the\nfollowing from the build directory:\n\n\n$ ninja test\n\n\n\n\nIf you'd rather build the tests \nwithout\n running them, you can call\n\nninja tests\n. In that case, you can execute the tests as described later in\n\nRunning Tests\n.\n\n\nBuilding the examples\n\n\nmettle comes with a series of examples to help show how to construct different\nkinds of tests. Similar to the above, you can build all of these with\n\nninja examples\n.\n\n\nBuilding the documentation\n\n\nmettle uses \nMkDocs\n for its documentation. To build the\ndocumentation, first install MkDocs, and then run \nninja doc-build\n. You can\nalso run \nninja doc-serve\n to run a test webserver with a preview of the\ndocumentation.", 
            "title": "Installation"
        }, 
        {
            "location": "/install/#installation", 
            "text": "Broadly, mettle is composed of three parts: a set of header files, a shared\nlibrary ( libmettle.so  or  mettle.dll ), and a universal test driver\n( mettle ). Before we can start using mettle, we'll need to build and install\nit.", 
            "title": "Installation"
        }, 
        {
            "location": "/install/#dependencies", 
            "text": "Before you get started with mettle, you'll need to install its dependencies:   A C++14-compliant compiler (for generic lambdas and various standard library\n  features)  clang  +  libc++  3.6+  GCC  +  libstdc++ \n   5.1+  MSVC  2015+    Boost  1.55+  bencode.hpp  bfg9000    Note  If you plan to use libc++,  this\nGist  should help you\nbuild Boost to link to it.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/install/#header-only-version", 
            "text": "If you don't want to install all of the above dependencies and build the\nbinaries for mettle, you can use this library in a header-only mode by using\nthe following instead of the usual  #include  mettle.hpp :  #include  mettle/header_only.hpp   However, the header-only version is quite limited and doesn't support any of the\ncommand-line arguments described in  Running Tests . In\naddition, if you don't have Boost installed, you'll need a standard library that\nincludes  std::experimental::string_view .", 
            "title": "Header-only version"
        }, 
        {
            "location": "/install/#building-and-installing", 
            "text": "Once you've installed all of mettle's dependencies, you can build mettle itself!\nTo build mettle, you'll first need to install bfg9000 . The snippets below assume you're\nusing the  Ninja  backend for bfg9000, but you can\nreplace this with any other build system bfg supports.  Building with bfg9000 is straightforward. Just run the following:  $ bfg9000 /path/to/mettle build\n$ cd build\n$ ninja install  You can specify the compiler to use and its options with the usual (Unix-style)\nenvironment variables, such as  CXX  and  CXXFLAGS . For further information\nabout how to use bfg9000, such as changing the build backend, see its documentation .", 
            "title": "Building and installing"
        }, 
        {
            "location": "/install/#testing-mettle", 
            "text": "Mettle's own tests are written entirely in mettle. (It wouldn't be a very good\ntest framework otherwise!) To build and run all the tests, just call the\nfollowing from the build directory:  $ ninja test  If you'd rather build the tests  without  running them, you can call ninja tests . In that case, you can execute the tests as described later in Running Tests .", 
            "title": "Testing mettle"
        }, 
        {
            "location": "/install/#building-the-examples", 
            "text": "mettle comes with a series of examples to help show how to construct different\nkinds of tests. Similar to the above, you can build all of these with ninja examples .", 
            "title": "Building the examples"
        }, 
        {
            "location": "/install/#building-the-documentation", 
            "text": "mettle uses  MkDocs  for its documentation. To build the\ndocumentation, first install MkDocs, and then run  ninja doc-build . You can\nalso run  ninja doc-serve  to run a test webserver with a preview of the\ndocumentation.", 
            "title": "Building the documentation"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Tutorial\n\n\nSo, you want to write some unit tests? This tutorial will walk you through the\nsteps needed to write, build, and run a simple test.\n\n\nYour first test\n\n\nLet's get started by taking a look at the test file we used when \nrunning\ntests\n. We'll discuss each part in detail below:\n\n\n#include \nmettle.hpp\n\nusing namespace mettle;\n\nsuite\n first(\nmy first suite\n, [](auto \n_) {\n  _.test(\nmy first test\n, []() {\n    expect(true, equal_to(true));\n  });\n});\n\n\n\n\nDissecting the test file\n\n\nFirst up, the obvious: we \n#include \nmettle.hpp\n, which imports all the code we\nneed to build and run simple tests: test suites, matchers, and a test runner.\nWith that out of the way, we can start defining our tests.\n\n\nAll tests are grouped into suites. Suites are created as global variables with\nthe type \nmettle::suite\n, and take a string name and a callback function\n(typically a lambda). The callback lets us define our tests for the suite. It\ntakes a single argument, a reference to a\n\nmettle::suite_builder\nmettle::expectation_failure\n, but since that's pretty\nlong, we conventionally just say \nauto \n and use a generic lambda instead:\n\n\nsuite\n first(\nmy first suite\n, [](auto \n_) {\n  /* ... */\n});\n\n\n\n\n\n\nNote\n\n\nThere are lots of other options you can pass to the suite's constructor,\nlike \nfixtures\n or \ntest\nattributes\n, but we'll get to those\nlater.\n\n\n\n\nWith the suite defined, now we just need to write our tests and add them via\nthe suite builder. Like suites, tests have both a string name and a callback\nfunction, but this time the callback is the code to run when the test executes:\n\n\n_.test((\nmy first test\n, []() {\n  /* ... */\n});\n\n\n\n\nInside our test function, we need to write some test code:\n\n\nexpect(true, equal_to(true));\n\n\n\n\nThis is an \nexpectation\n. We'll discuss them in more detail\n\nlater\n, but in short, they define the things we actually want\nto \ntest\n in our tests. This expectation makes sure that \ntrue\n is equal to\n\ntrue\n. If it's not, the test will alert us to the fact so we can fix it\n(hopefully before the universe finishes crashing down around us).\n\n\nBuilding the test\n\n\nBuilding a test is straightforward. Since mettle provides its own test runner\nwith a \nmain()\n function, the above source code is all you need for a\nfully-operational test. Just compile the test like so:\n\n\n$ clang++ -std=c++14 -lmettle -o test_first test_first.cpp\n\n\n\n\nRemember, mettle is a C++14 library, so you'll likely need to tell the compiler\nto use C++14 mode (or C++1y mode for slightly older compilers).\n\n\nRunning the test\n\n\nOnce you've built the test, you just need to run the binary and observe the\nresults. In this case, the results will look like:\n\n\n$ ./test_first\n.\n\n1/1 test passed\n\n\n\n\nThe single dot (\n.\n) shows that our one and only test passed, which the summary\nconfirms. However, if the unthinkable has happened and our test fails, we'd see\nsomething like this instead:\n\n\n$ ./test_first\n!\n\n0/1 tests passed\n  my first suite \n my first test FAILED\n    expected: true\n    actual:   false\n\n\n\n\nHere, we see an exclamation point (\n!\n) instead of a dot, to indicate a failed\ntest. At the end of the output, the details of the failure are shown. With this\ninformation, we can hopefully diagnose the failure and fix the bug.\n\n\nThere are many more options that can be supplied to the test binary to alter its\noutput or how it runs tests. To learn more about those, see \nRunning\nTests\n.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#tutorial", 
            "text": "So, you want to write some unit tests? This tutorial will walk you through the\nsteps needed to write, build, and run a simple test.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#your-first-test", 
            "text": "Let's get started by taking a look at the test file we used when  running\ntests . We'll discuss each part in detail below:  #include  mettle.hpp \nusing namespace mettle;\n\nsuite  first( my first suite , [](auto  _) {\n  _.test( my first test , []() {\n    expect(true, equal_to(true));\n  });\n});", 
            "title": "Your first test"
        }, 
        {
            "location": "/tutorial/#dissecting-the-test-file", 
            "text": "First up, the obvious: we  #include  mettle.hpp , which imports all the code we\nneed to build and run simple tests: test suites, matchers, and a test runner.\nWith that out of the way, we can start defining our tests.  All tests are grouped into suites. Suites are created as global variables with\nthe type  mettle::suite , and take a string name and a callback function\n(typically a lambda). The callback lets us define our tests for the suite. It\ntakes a single argument, a reference to a mettle::suite_builder mettle::expectation_failure , but since that's pretty\nlong, we conventionally just say  auto   and use a generic lambda instead:  suite  first( my first suite , [](auto  _) {\n  /* ... */\n});   Note  There are lots of other options you can pass to the suite's constructor,\nlike  fixtures  or  test\nattributes , but we'll get to those\nlater.   With the suite defined, now we just need to write our tests and add them via\nthe suite builder. Like suites, tests have both a string name and a callback\nfunction, but this time the callback is the code to run when the test executes:  _.test(( my first test , []() {\n  /* ... */\n});  Inside our test function, we need to write some test code:  expect(true, equal_to(true));  This is an  expectation . We'll discuss them in more detail later , but in short, they define the things we actually want\nto  test  in our tests. This expectation makes sure that  true  is equal to true . If it's not, the test will alert us to the fact so we can fix it\n(hopefully before the universe finishes crashing down around us).", 
            "title": "Dissecting the test file"
        }, 
        {
            "location": "/tutorial/#building-the-test", 
            "text": "Building a test is straightforward. Since mettle provides its own test runner\nwith a  main()  function, the above source code is all you need for a\nfully-operational test. Just compile the test like so:  $ clang++ -std=c++14 -lmettle -o test_first test_first.cpp  Remember, mettle is a C++14 library, so you'll likely need to tell the compiler\nto use C++14 mode (or C++1y mode for slightly older compilers).", 
            "title": "Building the test"
        }, 
        {
            "location": "/tutorial/#running-the-test", 
            "text": "Once you've built the test, you just need to run the binary and observe the\nresults. In this case, the results will look like:  $ ./test_first\n.\n\n1/1 test passed  The single dot ( . ) shows that our one and only test passed, which the summary\nconfirms. However, if the unthinkable has happened and our test fails, we'd see\nsomething like this instead:  $ ./test_first\n!\n\n0/1 tests passed\n  my first suite   my first test FAILED\n    expected: true\n    actual:   false  Here, we see an exclamation point ( ! ) instead of a dot, to indicate a failed\ntest. At the end of the output, the details of the failure are shown. With this\ninformation, we can hopefully diagnose the failure and fix the bug.  There are many more options that can be supplied to the test binary to alter its\noutput or how it runs tests. To learn more about those, see  Running\nTests .", 
            "title": "Running the test"
        }, 
        {
            "location": "/running-tests/", 
            "text": "Running Tests\n\n\nOnce you've built an executable test (if you haven't built one, be sure to read\nthe \ntutorial\n first), you'll find that there are a bunch of\noptions for running it. There are two main ways to run a test executable.\n\n\nRunning the test executable directly\n\n\nFor small projects, you may have only a single test executable. In this case,\nyou can simply run the file directly:\n\n\n$ ./test_my_code\n\n\n\n\nBelow\n, we'll see a list of the options we can pass to\nthe text executable, letting you tailor the output or how the tests are run.\n\n\nUsing the \nmettle\n universal test driver\n\n\nFor testing larger projects, it's generally recommended to divide your test\nsuites into multiple \n.cpp\n files and compile them into separate binaries. This\nallows you to improve build times and to better isolate tests from each other.\n\n\nWhen doing so, you can use the \nmettle\n executable to run all of your individual\nbinaries at once. The interface is much like that of the individual binaries,\nand all of the command-line options above work with the \nmettle\n executable as\nwell. To specify which of the test binaries to run, just pass their filenames to\n\nmettle\n:\n\n\n$ mettle test_file1 test_file2\n\n\n\n\nLike the individual test executables, the \nmettle\n driver accepts several\n\noptions\n to modify its behavior and output.\n\n\nForwarding arguments\n\n\nYou can also pass along arguments to a test binary by quoting the binary:\n\n\n$ mettle test_file1 \ncaliber test_foo.cpp test_bar.cpp\n\n\n\n\n\nThis executes \ntest_file1\n and then executes \ncaliber\n with two arguments:\n\ntest_foo.cpp\n and \ntest_bar.cpp\n. You can also pass wildcards (globs) inside\nquoted arguments:\n\n\n$ mettle test_file1 \ncaliber test_*.cpp\n\n\n\n\n\nCommand-line options\n\n\nGeneric options\n\n\n--help (-h)\n\n\nShow help and usage information.\n\n\nDriver options\n\n\n--timeout \nN\n (-t)\n\n\nTime out and fail any tests that take longer than \nN\n milliseconds to execute.\n\n\n\n\nWarning\n\n\n--no-subproc\n can't be specified while using this option.\n\n\n\n\n--test \nREGEX\n (-T)\n\n\nFilter the tests that will be run to those matching a regex. If \n--test\n is\nspecified multiple times, tests that match \nany\n of the regexes will be run.\n\n\n--attr \nATTR[=VALUE],...\n (-a)\n\n\nFilter the tests that will be run based on the tests'\n\nattributes\n. Tests matching each of the\nattributes (and, optionally, values) will be run by the test driver. If \n--attr\n\nis specified multiple times, tests that match \nany\n of the filters will be run.\nYou can also prepend \nATTR\n with \n!\n to negate that test. Let's look at some\nexamples to get a better sense of how this works:\n\n\n\n\n\n\n--attr slow\n\n\nRun only tests with the attribute \nslow\n.\n\n\n\n\n\n\n--attr protocol=http\n\n\nRun only tests with the attribute \nprotocol\n having a value of \nhttp\n.\n\n\n\n\n\n\n--attr '!slow'\n\n\nRun only tests \nwithout\n the attribute \nslow\n. (Note the use of quotation\nmarks, since many shells treat \n!\n as a special character.)\n\n\n\n\n\n\n--attr '!protocol=http'\n\n\nRun only tests \nwithout\n the attribute \nprotocol\n, or which have \nprotocol\n\nset to something other than \nhttp\n.\n\n\n\n\n\n\n--attr slow,protocol=http\n\n\nRun only tests that match both attributes.\n\n\n\n\n\n\n--attr slow --attr protocol=http\n\n\nRun tests that match either attribute.\n\n\n\n\n\n\n--no-subproc\n\n\nBy default, mettle creates a subprocess for each test, in order to detect\ncrashes during the execution of a test. To disable this, you can pass\n\n--no-subproc\n, and all the tests will run in the same process. This option can\nonly be specified for the individual test binaries, \nnot\n for the \nmettle\n\ndriver.\n\n\nOutput options\n\n\n--output \nFORMAT\n (-o)\n\n\nSet the output format for the test results. If \n--output\n isn't passed, the\nformat is set to \nbrief\n. The available formats are:\n\n\n\n\nsilent\n: Don't show any output during the test run; only a summary after the\n  fact will be shown.\n\n\nbrief\n: A single character for each test will be shown. \n.\n means a passed\n  test, \n!\n a failed test, and \n_\n a skipped test.\n\n\nverbose\n: Show the full name of tests and suites as they're being run.\n\n\n\n\n--color \n[WHEN]\n (-c)\n\n\nPrint test results in color. This is good if your terminal supports colors,\nsince it makes the results much easier to read! \nWHEN\n can be one of \nalways\n\n(the default if you don't explicitly specify \nWHEN\n), \nnever\n, or \nauto\n.\n\n\n--runs \nN\n (-n)\n\n\nRun the tests a total of \nN\n times. This is useful for catching intermittent\nfailures. At the end, the summary will show the output of each failure for every\ntest.\n\n\n--show-terminal\n\n\nShow the terminal output (stdout and stderr) of each test after it finishes. To\nenable this, \n--no-subproc\n can't be specified (if \n--no-subproc\n \nis\n\nspecified, the terminal output will just appear in-line with the tests).\n\n\n--show-time\n\n\nShow the duration (in milliseconds) of each test as it runs, as well as the\ntotal time of the entire job.", 
            "title": "Running Tests"
        }, 
        {
            "location": "/running-tests/#running-tests", 
            "text": "Once you've built an executable test (if you haven't built one, be sure to read\nthe  tutorial  first), you'll find that there are a bunch of\noptions for running it. There are two main ways to run a test executable.", 
            "title": "Running Tests"
        }, 
        {
            "location": "/running-tests/#running-the-test-executable-directly", 
            "text": "For small projects, you may have only a single test executable. In this case,\nyou can simply run the file directly:  $ ./test_my_code  Below , we'll see a list of the options we can pass to\nthe text executable, letting you tailor the output or how the tests are run.", 
            "title": "Running the test executable directly"
        }, 
        {
            "location": "/running-tests/#using-the-mettle-universal-test-driver", 
            "text": "For testing larger projects, it's generally recommended to divide your test\nsuites into multiple  .cpp  files and compile them into separate binaries. This\nallows you to improve build times and to better isolate tests from each other.  When doing so, you can use the  mettle  executable to run all of your individual\nbinaries at once. The interface is much like that of the individual binaries,\nand all of the command-line options above work with the  mettle  executable as\nwell. To specify which of the test binaries to run, just pass their filenames to mettle :  $ mettle test_file1 test_file2  Like the individual test executables, the  mettle  driver accepts several options  to modify its behavior and output.", 
            "title": "Using the mettle universal test driver"
        }, 
        {
            "location": "/running-tests/#forwarding-arguments", 
            "text": "You can also pass along arguments to a test binary by quoting the binary:  $ mettle test_file1  caliber test_foo.cpp test_bar.cpp   This executes  test_file1  and then executes  caliber  with two arguments: test_foo.cpp  and  test_bar.cpp . You can also pass wildcards (globs) inside\nquoted arguments:  $ mettle test_file1  caliber test_*.cpp", 
            "title": "Forwarding arguments"
        }, 
        {
            "location": "/running-tests/#command-line-options", 
            "text": "", 
            "title": "Command-line options"
        }, 
        {
            "location": "/running-tests/#generic-options", 
            "text": "", 
            "title": "Generic options"
        }, 
        {
            "location": "/running-tests/#-help-h", 
            "text": "Show help and usage information.", 
            "title": "--help (-h)"
        }, 
        {
            "location": "/running-tests/#driver-options", 
            "text": "", 
            "title": "Driver options"
        }, 
        {
            "location": "/running-tests/#-timeout-n-t", 
            "text": "Time out and fail any tests that take longer than  N  milliseconds to execute.   Warning  --no-subproc  can't be specified while using this option.", 
            "title": "--timeout N (-t)"
        }, 
        {
            "location": "/running-tests/#-test-regex-t", 
            "text": "Filter the tests that will be run to those matching a regex. If  --test  is\nspecified multiple times, tests that match  any  of the regexes will be run.", 
            "title": "--test REGEX (-T)"
        }, 
        {
            "location": "/running-tests/#-attr-attrvalue-a", 
            "text": "Filter the tests that will be run based on the tests' attributes . Tests matching each of the\nattributes (and, optionally, values) will be run by the test driver. If  --attr \nis specified multiple times, tests that match  any  of the filters will be run.\nYou can also prepend  ATTR  with  !  to negate that test. Let's look at some\nexamples to get a better sense of how this works:    --attr slow  Run only tests with the attribute  slow .    --attr protocol=http  Run only tests with the attribute  protocol  having a value of  http .    --attr '!slow'  Run only tests  without  the attribute  slow . (Note the use of quotation\nmarks, since many shells treat  !  as a special character.)    --attr '!protocol=http'  Run only tests  without  the attribute  protocol , or which have  protocol \nset to something other than  http .    --attr slow,protocol=http  Run only tests that match both attributes.    --attr slow --attr protocol=http  Run tests that match either attribute.", 
            "title": "--attr ATTR[=VALUE],... (-a)"
        }, 
        {
            "location": "/running-tests/#-no-subproc", 
            "text": "By default, mettle creates a subprocess for each test, in order to detect\ncrashes during the execution of a test. To disable this, you can pass --no-subproc , and all the tests will run in the same process. This option can\nonly be specified for the individual test binaries,  not  for the  mettle \ndriver.", 
            "title": "--no-subproc"
        }, 
        {
            "location": "/running-tests/#output-options", 
            "text": "", 
            "title": "Output options"
        }, 
        {
            "location": "/running-tests/#-output-format-o", 
            "text": "Set the output format for the test results. If  --output  isn't passed, the\nformat is set to  brief . The available formats are:   silent : Don't show any output during the test run; only a summary after the\n  fact will be shown.  brief : A single character for each test will be shown.  .  means a passed\n  test,  !  a failed test, and  _  a skipped test.  verbose : Show the full name of tests and suites as they're being run.", 
            "title": "--output FORMAT (-o)"
        }, 
        {
            "location": "/running-tests/#-color-when-c", 
            "text": "Print test results in color. This is good if your terminal supports colors,\nsince it makes the results much easier to read!  WHEN  can be one of  always \n(the default if you don't explicitly specify  WHEN ),  never , or  auto .", 
            "title": "--color [WHEN] (-c)"
        }, 
        {
            "location": "/running-tests/#-runs-n-n", 
            "text": "Run the tests a total of  N  times. This is useful for catching intermittent\nfailures. At the end, the summary will show the output of each failure for every\ntest.", 
            "title": "--runs N (-n)"
        }, 
        {
            "location": "/running-tests/#-show-terminal", 
            "text": "Show the terminal output (stdout and stderr) of each test after it finishes. To\nenable this,  --no-subproc  can't be specified (if  --no-subproc   is \nspecified, the terminal output will just appear in-line with the tests).", 
            "title": "--show-terminal"
        }, 
        {
            "location": "/running-tests/#-show-time", 
            "text": "Show the duration (in milliseconds) of each test as it runs, as well as the\ntotal time of the entire job.", 
            "title": "--show-time"
        }, 
        {
            "location": "/writing-tests/", 
            "text": "Writing Tests\n\n\nBelow, we'll look at how test files are structured, how to create the tests\nthemselves, and how to group them together to perform higher-level operations on\nthem. Throughout this page, we'll assume that the following appears at the\nbeginning of our examples:\n\n\n#include \nmettle.hpp\n\n\n\n\n\nThis includes \nall\n the headers necessary to use mettle. Alternately, you can\n\n#include \nmettle/header_only.hpp\n if you prefer to use mettle without\ncompiling \nlibmettle.so\n and the \nmettle\n universal driver.\n\n\nIf you'd rather include a smaller subset of headers, e.g. to improve compilation\nspeeds, you'll need the following to define tests and suites:\n\n\n#include \nmettle/suite.hpp\n\n\n// Choose only one of these:\n#include \nmettle/driver/lib_driver.hpp\n    // The driver to go with libmettle.so\n#include \nmettle/driver/header_driver.hpp\n // The header-only driver\n\n\n\n\nDefining suites\n\n\nIn mettle, all tests are grouped by suites. Suites are generally defined as\nglobal variables (we'll see more ways to define suites later), and take two\narguments in the constructor: a string name, and a callback function taking a\nreference to a \nmettle::suite_builder\nmettle::expectation_failure\n. Generally,\nwe just define the callback as a generic lambda:\n\n\nmettle::suite\n my_suite(\nmy suite\n, [](auto \n_) {\n  /* ... */\n});\n\n\n\n\nIf you don't plan to use mettle's \nexpectations\n for checking\nprogram state, you can replace \nmettle::suite\n with\n\nmettle::basic_suite\nmy_exception\n to create a test suite using your own\nexception type as the \"canonical\" exception.\n\n\nTests\n\n\nWhile we have a suite now, we still need to define some tests. Tests are,\nwithout a doubt, the most important part of a \ntest\n suite. We define our tests\ninside our suite's callback function, using the \nsuite_builder\n passed into it.\nLike our suite, each test takes two arguments: a string name, and a callback\nfunction defining the test. However, the test's callback takes no arguments:\n\n\nmettle::suite\n my_suite(\nmy suite\n, [](auto \n_) {\n  _.test(\nmy test\n, []() {\n    /* ... */\n  });\n});\n\n\n\n\nInside the test's callback function, we can write our actual test. If our code\nthrows an exception, the test will fail; otherwise, it passes. Most of your\ntests should use \nexpectations\n (similar to assertions) to\nperform the actual tests. Expectations provide informative error messages if any\npart of your test fails.\n\n\nSetup and teardown\n\n\nSometimes, you'll have a bunch of tests that all have the same setup and\nteardown code. Test fixtures let you do this (mostly) automatically. If a test\nsuite has a \nsetup\n or \nteardown\n function set, they'll run before (or after)\neach test in the suite:\n\n\nmettle::suite\n with_setup(\nmy suite\n, [](auto \n_) {\n  _.setup([]() {\n    /* ... */\n  });\n\n  _.teardown([]() {\n    /* ... */\n  });\n\n  _.test(\nmy test\n, []() {\n    /* ... */\n  });\n});\n\n\n\n\nSubsuites\n\n\nWhen testing something particularly complex, you might find it useful to group\ntest suites together. You can do this by creating a subsuite inside a parent\nsuite:\n\n\nmettle::suite\n with_subsuites(\nsuite with subsuites\n, [](auto \n_) {\n  _.subsuite(\nsubsuite\n, [](auto \n_) {\n    _.test(\nmy subtest\n, []() {\n      /* ... */\n    });\n  });\n});\n\n\n\n\nYou might have noticed above that, unlike for the root suite, our subsuite\ndoesn't contain an empty template parameter list (read: there's no \n). Since\n\nsubsuite\n is just a member function, the angle brackets aren't necessary, but\nwhat if you want to supply a fixture for your subsuite? That's where it gets a\nbit more complex. As you may recall, our suite's callback uses a generic lambda,\nand so \n_\n is a \ndependent type\n. Template member functions of a dependent type\nmust be prefixed with the \ntemplate\n keyword, like so:\n\n\n_.template subsuite\nint\n(\nsubsuite\n, [](auto \n_) {\n  /* ... */\n});\n\n\n\n\nHowever, this is rather ugly. To eliminate the \ntemplate\n keyword, we could\neither redefine our lambda to no longer be generic, or just use the\n\nmettle::subsuite\n helper:\n\n\nmettle::subsuite\n(_, \nsubsuite\n, [](auto \n_) {\n  /* ... */\n});\n\n\n\n\nNested setup and teardown\n\n\nAs you might imagine, a test in a subsuite uses not only the subsuite's setup\nand teardown functions, but inherits the parent suite's as well (and so on up\nthe tree). When executing a test in a subsuite, the test runner will walk down\nthe suite hierarchy, calling each setup function in turn before running the\ntest. After finishing the test, it will walk back up the tree calling each\nteardown function.\n\n\nFor a two-level hierarchy, this is what would happen for each test in the\nsubsuite:\n\n\n\n\nCall the parent suite's setup function (if defined).\n\n\nCall the subsuite's setup function (if defined).\n\n\nRun the test function\n\n\nCall the subsuite's teardown function (if defined).\n\n\nCall the parent suite's teardown function (if defined).\n\n\n\n\nFixtures\n\n\nSetup and teardown functions are of limited use without fixtures. Fixtures allow\nyou to safely write multiple, independent tests that test the same object. Each\ntest gets its own instance of the fixture, preventing it from affecting any of\nthe other tests. A fixture's lifetime is as follows:\n\n\n\n\nConstructor the fixture using the default constructor.\n\n\nPass the fixture by reference to the setup function (if defined).\n\n\nPass the fixture by reference to the test function.\n\n\nPass the fixture by reference to the teardown function (if defined).\n\n\nDestruct the fixture.\n\n\n\n\nDeclaring a fixture is simple. Just pass the type of your fixture in the\ntemplate parameters of your \nmettle::suite\n object:\n\n\nstruct my_fixture {\n  int i;\n};\n\nmettle::suite\nmy_fixture\n with_fixture(\nsuite with a fixture\n, [](auto \n_) {\n  _.setup([](my_fixture \nf) {\n    f.i = 1;\n  });\n\n  _.test(\ntest my fixture\n, [](my_fixture \nf) {\n    mettle::expect(f.i, equal_to(1));\n  });\n});\n\n\n\n\nAstute readers will notice that a test fixture could easily be used to replace\nthe \nsetup\n and \nteardown\n functions by using RAII. However, both options are\nsupported, since it's often simpler to write a setup/teardown code than to write\na less-flexible helper class. For instance, your fixture might be a database\nobject from your production code that you want to add some test records to for\ntesting. Rather than wrapping the database in a helper, you can just add the\ntest records in \nsetup\n.\n\n\nSometimes, the default constructor for a fixture isn't appropriate. In these\ncases, you can use \nfixture factories\n, discussed below.\n\n\nNested fixtures\n\n\nLike the nested setup and teardown functions, test fixtures are also\ninherited in subsuites. This allows a parent suite to handle common fixtures for\na bunch of subsuites, reducing code duplication:\n\n\nmettle::suite\nint\n nested_fixtures(\nsuite with subsuites\n, [](auto \n_) {\n  _.setup([](int \ni) {\n    i = 1;\n  });\n\n  _.test(\nmy parent test\n, [](int \ni) {\n    mettle::expect(i, equal_to(1));\n  });\n\n  mettle::subsuite\nstd::string\n(_, \nsubsuite\n, [](auto \n_) {\n    _.setup([](int \ni, std::string \ns) {\n      i++;\n      s = \nfoo\n;\n    });\n\n    _.test(\nmy subtest\n, [](int \ni, std::string \ns) {\n      mettle::expect(i, equal_to(2));\n      mettle::expect(s, equal_to(\nfoo\n));\n    });\n  });\n});\n\n\n\n\nAs you can see above, subsuites inherit their parents' fixtures, much like they\ninherit their parents' setup and teardown functions.\n\n\nFixture factories\n\n\nSometimes, a fixture can't be constructed as is, e.g if the fixture isn't\ndefault-constructible. In these cases, you can use a \nfixture factory\n to create\nyour fixture object with any parameters you like. For simple cases, we can use\n\nmettle::bind_factory\n, which takes a list of arguments and constructs an object\nof your fixture's type with those arguments:\n\n\nmettle::suite\nint\n\nbound_fixture(\nusing bind_factory\n, mettle::bind_factory(3), [](auto \n_) {\n  _.test([](int \ni) {\n    mettle::expect(i, equal_to(3));\n  });\n});\n\n\n\n\nFor more complex fixtures, you can create your own factories from scratch. A\nfixture factory is simply an object with a templated \nmake\nT\n()\n function:\n\n\nstruct my_factory {\n  template\ntypename T\n\n  T make() {\n    return T(12);\n  }\n};\n\nmettle::suite\nmy_fixture\n with_factory(\nsuite\n, my_factory{}, [](auto \n_) {\n  /* ... */\n});\n\n\n\n\nIn fact, even \"ordinary\" fixtures use their own factory: \nauto_factory\n. The\nfollowing code snippets are equivalent:\n\n\nmettle::suite\nmy_fixture\n\nwithout_auto_factory(\nsuite\n, [](auto \n_) {\n  /* ... */\n});\n\nmettle::suite\nmy_fixture\n\nwith_auto_factory(\nsuite\n, mettle::auto_factory, [](auto \n_) {\n  /* ... */\n});\n\n\n\n\nLater, we'll learn more about fixture factories and how to\n\ntransform\n their types.\n\n\nParameterizing tests\n\n\nWhile suites are a good way to group your tests together, sometimes you want to\nrun the \nsame\n tests on several different types of objects. In this case, all\nyou need to do is specify \nmultiple\n fixtures when defining a test suite. The\nexample below creates two test suites, one with a fixture of \nint\n and one with\na fixture of \nfloat\n:\n\n\nmettle::suite\nint, float\n param_test(\nparameterized suite\n, [](auto \n_) {\n  _.test(\nmy test\n, [](auto \nfixture) {\n    /* ... */\n  });\n});\n\n\n\n\nThis works just the same for subsuites as well:\n\n\nmettle::suite\n param_sub_test(\nparameterized subsuites\n, [](auto \n_) {\n  mettle::subsuite\nint, float\n(_, \nparameterized suite 1\n, [](auto \n_) {\n    /* ... */\n  });\n\n  _.template subsuite\nint, float\n(_, \nparameterized suite 2\n, [](auto \n_) {\n    /* ... */\n  });\n});\n\n\n\n\nOne subtle difference you may have noticed is that now, our test definitions\nuse a generic lambda: \n[](auto \nfixture) { /* ... */ }\n. As you might imagine,\nthis allows the test function to accept a fixture of either an \nint\n or a\n\nfloat\n and to do the usual thing when a template is instantiated. Of course,\nyou don't \nalways\n need to use \nauto\n here; if all of your fixtures inherit from\na common base type, you can use an ordinary lambda that takes a reference to the\nbase type.\n\n\nTransforming fixture types\n\n\nEarlier, we learned about \nfixture factories\n. We can do\neven more with them, though: a fixture factory's \nmake\nT\n()\n can actually return\n\nany\n type (including \nvoid\n!), not just \nT\n. This can be useful for more\ncomplex tests, like testing a container type with several different element\ntypes:\n\n\nstruct vector_factory {\n  template\ntypename T\n\n  std::vector\nT\n make() {\n    return {};\n  }\n};\n\nmettle::suite\nint, float\n vector_suite(\nsuite\n, vector_factory{}, [](auto \n_) {\n  _.test(\nempty()\n, [](auto \nvec) {\n    mettle::expect(vec.empty(), equal_to(true));\n  });\n});\n\n\n\n\nType-only fixtures\n\n\nAs mentioned above, a fixture factory's \nmake\nT\n()\n can return \nvoid\n. In this\ncase, the suite has no fixture whatsoever. This is primarily useful when you\nwant to parameterize on a list of types, but you don't want to automatically\ninstantiate the fixture object. The built-in fixture factory \ntype_only\n handles\nthis for you. In particular, note the parameter-less test function:\n\n\nmettle::suite\nint, float\n type_only(\nsuite\n, mettle::type_only, [](auto \n_) {\n  _.test(\nempty()\n, []() {\n    /* ... */\n  });\n});\n\n\n\n\nGetting the parameterized type\n\n\nIn some cases, you may want to know the parameterized type, e.g. if you'd like\nto create your own instances of the object. You can retrieve this via the\n\nfixture_type\n trait (or the \nfixture_type_t\n alias) like so:\n\n\nmettle::suite\nint, float\n param_type(\nsuite\n, mettle::type_only, [](auto \n_) {\n  using Fixture = mettle::fixture_type_t\ndecltype(_)\n;\n\n  _.test(\nmy test\n, []() {\n    /* use Fixture here */\n  });\n});\n\n\n\n\nTest attributes\n\n\nFor large projects with many tests, it can be useful to run only a subset of\nthem, instead of the entire collection. While splitting up tests by file can\nhelp, it doesn't allow for very precise control of what tests get run. Instead,\nyou can apply attributes to your tests (or whole suites!) and filter on them.\n\n\nThe \nskip\n attribute\n\n\nmettle provides one built-in attribute: \nmettle::skip\n. As the name implies,\nthis attribute causes a test to be skipped by default. This can be useful when a\ntest is broken, since the test runner will keep track of the skipped tests as a\nreminder that you need to go back and fix the test. You can also provide a\ncomment for the skipped test that will be shown in the test logs explaining why\nit was skipped.\n\n\nFor more information about how to use the \nskip\n attribute, see \nUsing\nAttributes\n below.\n\n\nDefining attributes\n\n\nIn addition to the built-in \nskip\n attribute, you can define your own\nattributes. There are three basic kinds of attributes, differentiated by the\nnumber of values each can hold: \nmettle::bool_attr\n, which holds 0 or 1 values;\n\nmettle::string_attr\n, which holds exactly 1 value; and \nmettle::list_attr\n,\nwhich holds 1 or more distinct values.\n\n\nbool_attr\ns are somewhat special and can be given a default action\nwhen they're encountered (either \nmettle::attr_action::run\n or\n\nmettle::attr_action::skip\n). As you might be able to guess, the predefined\n\nskip\n attribute is just a \nbool_attr\n whose action is \nattr_action::skip\n.\n\n\nTo define an attribute, you just need to create a global instance of one of the\naforementioned attribute kinds:\n\n\nmettle::bool_attr slow(\nslow\n);\nmettle::bool_attr busted(\nbusted\n, attr_action::skip);\nmettle::list_attr tags(\ntags\n);\n\n\n\n\nUsing attributes\n\n\nIt's easy to apply attributes to your tests: simply create instances of each\nkind of attribute you want, and pass them to the test creation function\nimmediately after the test name:\n\n\n_.test(\nmy test\n, {mettle::skip, slow(\ntakes too long\n), tags(\ncat\n, \ngoat\n)},\n       [](auto \nfixture) { /* ... */ });\n\n\n\n\nThis creates a \nmettle::attributes\n object that gets stored alongside the test.\nAs you might notice, \nbool_attrs\n can be implicitly converted to an attribute\ninstance, but other types require you to call them to list their values.\n\n\nSuite attributes\n\n\nLike tests, whole suites can have attributes associated with them; these are\napplied the same way as for tests, and the list of attributes will automatically\nbe inherited by any children (tests or subsuites). The children can set their\nown attributes, and all the attributes in the hierarchy will be combined\ntogether for each test.\n\n\nFor \nbool_attr\ns and \nstring_attr\ns, children with the same attribute as their\nparents will \noverride\n the parent's attribute, but for \nlist_attr\ns, the\nvalues from the parent and child will be merged:\n\n\nmettle::suite\n\nattr_suite(\nmy suite\n, {mettle::skip(\nbroken\n), tags(\ncat\n)}, [](auto \n_) {\n  _.test(\nmy test\n, {slow, mettle::skip(\nfixme\n), tags(\ndog\n)}, []() {\n    /* This test has the following attributes: slow, skip(\nfixme\n), and\n       tags(\ncat\n, \ndog\n). */\n  });\n});\n\n\n\n\nMixing fixture factories and attributes\n\n\nAt this point, you may be wondering how to specify \nboth\n a fixture factory and\na set of attributes for suite. Since they're both optional arguments that appear\nbetween the suite's name and its creation function, which goes first? \nThe\nattributes always go first\n:\n\n\nmettle::suite\nint\n\nthe_works(\nmy complicated suite\n, {mettle::skip}, type_only, [](auto \n_) {\n  /* ... */\n});\n\n\n\n\nThere's an easy rule to remember this: since attributes are a way of identifying\nthe suite, they go near the other identifier: the name. Likewise, fixture\nfactories affect how the suite is \nexecuted\n, so they go near the creation\nfunction, which also affects its execution.", 
            "title": "Writing Tests"
        }, 
        {
            "location": "/writing-tests/#writing-tests", 
            "text": "Below, we'll look at how test files are structured, how to create the tests\nthemselves, and how to group them together to perform higher-level operations on\nthem. Throughout this page, we'll assume that the following appears at the\nbeginning of our examples:  #include  mettle.hpp   This includes  all  the headers necessary to use mettle. Alternately, you can #include  mettle/header_only.hpp  if you prefer to use mettle without\ncompiling  libmettle.so  and the  mettle  universal driver.  If you'd rather include a smaller subset of headers, e.g. to improve compilation\nspeeds, you'll need the following to define tests and suites:  #include  mettle/suite.hpp \n\n// Choose only one of these:\n#include  mettle/driver/lib_driver.hpp     // The driver to go with libmettle.so\n#include  mettle/driver/header_driver.hpp  // The header-only driver", 
            "title": "Writing Tests"
        }, 
        {
            "location": "/writing-tests/#defining-suites", 
            "text": "In mettle, all tests are grouped by suites. Suites are generally defined as\nglobal variables (we'll see more ways to define suites later), and take two\narguments in the constructor: a string name, and a callback function taking a\nreference to a  mettle::suite_builder mettle::expectation_failure . Generally,\nwe just define the callback as a generic lambda:  mettle::suite  my_suite( my suite , [](auto  _) {\n  /* ... */\n});  If you don't plan to use mettle's  expectations  for checking\nprogram state, you can replace  mettle::suite  with mettle::basic_suite my_exception  to create a test suite using your own\nexception type as the \"canonical\" exception.", 
            "title": "Defining suites"
        }, 
        {
            "location": "/writing-tests/#tests", 
            "text": "While we have a suite now, we still need to define some tests. Tests are,\nwithout a doubt, the most important part of a  test  suite. We define our tests\ninside our suite's callback function, using the  suite_builder  passed into it.\nLike our suite, each test takes two arguments: a string name, and a callback\nfunction defining the test. However, the test's callback takes no arguments:  mettle::suite  my_suite( my suite , [](auto  _) {\n  _.test( my test , []() {\n    /* ... */\n  });\n});  Inside the test's callback function, we can write our actual test. If our code\nthrows an exception, the test will fail; otherwise, it passes. Most of your\ntests should use  expectations  (similar to assertions) to\nperform the actual tests. Expectations provide informative error messages if any\npart of your test fails.", 
            "title": "Tests"
        }, 
        {
            "location": "/writing-tests/#setup-and-teardown", 
            "text": "Sometimes, you'll have a bunch of tests that all have the same setup and\nteardown code. Test fixtures let you do this (mostly) automatically. If a test\nsuite has a  setup  or  teardown  function set, they'll run before (or after)\neach test in the suite:  mettle::suite  with_setup( my suite , [](auto  _) {\n  _.setup([]() {\n    /* ... */\n  });\n\n  _.teardown([]() {\n    /* ... */\n  });\n\n  _.test( my test , []() {\n    /* ... */\n  });\n});", 
            "title": "Setup and teardown"
        }, 
        {
            "location": "/writing-tests/#subsuites", 
            "text": "When testing something particularly complex, you might find it useful to group\ntest suites together. You can do this by creating a subsuite inside a parent\nsuite:  mettle::suite  with_subsuites( suite with subsuites , [](auto  _) {\n  _.subsuite( subsuite , [](auto  _) {\n    _.test( my subtest , []() {\n      /* ... */\n    });\n  });\n});  You might have noticed above that, unlike for the root suite, our subsuite\ndoesn't contain an empty template parameter list (read: there's no  ). Since subsuite  is just a member function, the angle brackets aren't necessary, but\nwhat if you want to supply a fixture for your subsuite? That's where it gets a\nbit more complex. As you may recall, our suite's callback uses a generic lambda,\nand so  _  is a  dependent type . Template member functions of a dependent type\nmust be prefixed with the  template  keyword, like so:  _.template subsuite int ( subsuite , [](auto  _) {\n  /* ... */\n});  However, this is rather ugly. To eliminate the  template  keyword, we could\neither redefine our lambda to no longer be generic, or just use the mettle::subsuite  helper:  mettle::subsuite (_,  subsuite , [](auto  _) {\n  /* ... */\n});", 
            "title": "Subsuites"
        }, 
        {
            "location": "/writing-tests/#nested-setup-and-teardown", 
            "text": "As you might imagine, a test in a subsuite uses not only the subsuite's setup\nand teardown functions, but inherits the parent suite's as well (and so on up\nthe tree). When executing a test in a subsuite, the test runner will walk down\nthe suite hierarchy, calling each setup function in turn before running the\ntest. After finishing the test, it will walk back up the tree calling each\nteardown function.  For a two-level hierarchy, this is what would happen for each test in the\nsubsuite:   Call the parent suite's setup function (if defined).  Call the subsuite's setup function (if defined).  Run the test function  Call the subsuite's teardown function (if defined).  Call the parent suite's teardown function (if defined).", 
            "title": "Nested setup and teardown"
        }, 
        {
            "location": "/writing-tests/#fixtures", 
            "text": "Setup and teardown functions are of limited use without fixtures. Fixtures allow\nyou to safely write multiple, independent tests that test the same object. Each\ntest gets its own instance of the fixture, preventing it from affecting any of\nthe other tests. A fixture's lifetime is as follows:   Constructor the fixture using the default constructor.  Pass the fixture by reference to the setup function (if defined).  Pass the fixture by reference to the test function.  Pass the fixture by reference to the teardown function (if defined).  Destruct the fixture.   Declaring a fixture is simple. Just pass the type of your fixture in the\ntemplate parameters of your  mettle::suite  object:  struct my_fixture {\n  int i;\n};\n\nmettle::suite my_fixture  with_fixture( suite with a fixture , [](auto  _) {\n  _.setup([](my_fixture  f) {\n    f.i = 1;\n  });\n\n  _.test( test my fixture , [](my_fixture  f) {\n    mettle::expect(f.i, equal_to(1));\n  });\n});  Astute readers will notice that a test fixture could easily be used to replace\nthe  setup  and  teardown  functions by using RAII. However, both options are\nsupported, since it's often simpler to write a setup/teardown code than to write\na less-flexible helper class. For instance, your fixture might be a database\nobject from your production code that you want to add some test records to for\ntesting. Rather than wrapping the database in a helper, you can just add the\ntest records in  setup .  Sometimes, the default constructor for a fixture isn't appropriate. In these\ncases, you can use  fixture factories , discussed below.", 
            "title": "Fixtures"
        }, 
        {
            "location": "/writing-tests/#nested-fixtures", 
            "text": "Like the nested setup and teardown functions, test fixtures are also\ninherited in subsuites. This allows a parent suite to handle common fixtures for\na bunch of subsuites, reducing code duplication:  mettle::suite int  nested_fixtures( suite with subsuites , [](auto  _) {\n  _.setup([](int  i) {\n    i = 1;\n  });\n\n  _.test( my parent test , [](int  i) {\n    mettle::expect(i, equal_to(1));\n  });\n\n  mettle::subsuite std::string (_,  subsuite , [](auto  _) {\n    _.setup([](int  i, std::string  s) {\n      i++;\n      s =  foo ;\n    });\n\n    _.test( my subtest , [](int  i, std::string  s) {\n      mettle::expect(i, equal_to(2));\n      mettle::expect(s, equal_to( foo ));\n    });\n  });\n});  As you can see above, subsuites inherit their parents' fixtures, much like they\ninherit their parents' setup and teardown functions.", 
            "title": "Nested fixtures"
        }, 
        {
            "location": "/writing-tests/#fixture-factories", 
            "text": "Sometimes, a fixture can't be constructed as is, e.g if the fixture isn't\ndefault-constructible. In these cases, you can use a  fixture factory  to create\nyour fixture object with any parameters you like. For simple cases, we can use mettle::bind_factory , which takes a list of arguments and constructs an object\nof your fixture's type with those arguments:  mettle::suite int \nbound_fixture( using bind_factory , mettle::bind_factory(3), [](auto  _) {\n  _.test([](int  i) {\n    mettle::expect(i, equal_to(3));\n  });\n});  For more complex fixtures, you can create your own factories from scratch. A\nfixture factory is simply an object with a templated  make T ()  function:  struct my_factory {\n  template typename T \n  T make() {\n    return T(12);\n  }\n};\n\nmettle::suite my_fixture  with_factory( suite , my_factory{}, [](auto  _) {\n  /* ... */\n});  In fact, even \"ordinary\" fixtures use their own factory:  auto_factory . The\nfollowing code snippets are equivalent:  mettle::suite my_fixture \nwithout_auto_factory( suite , [](auto  _) {\n  /* ... */\n});\n\nmettle::suite my_fixture \nwith_auto_factory( suite , mettle::auto_factory, [](auto  _) {\n  /* ... */\n});  Later, we'll learn more about fixture factories and how to transform  their types.", 
            "title": "Fixture factories"
        }, 
        {
            "location": "/writing-tests/#parameterizing-tests", 
            "text": "While suites are a good way to group your tests together, sometimes you want to\nrun the  same  tests on several different types of objects. In this case, all\nyou need to do is specify  multiple  fixtures when defining a test suite. The\nexample below creates two test suites, one with a fixture of  int  and one with\na fixture of  float :  mettle::suite int, float  param_test( parameterized suite , [](auto  _) {\n  _.test( my test , [](auto  fixture) {\n    /* ... */\n  });\n});  This works just the same for subsuites as well:  mettle::suite  param_sub_test( parameterized subsuites , [](auto  _) {\n  mettle::subsuite int, float (_,  parameterized suite 1 , [](auto  _) {\n    /* ... */\n  });\n\n  _.template subsuite int, float (_,  parameterized suite 2 , [](auto  _) {\n    /* ... */\n  });\n});  One subtle difference you may have noticed is that now, our test definitions\nuse a generic lambda:  [](auto  fixture) { /* ... */ } . As you might imagine,\nthis allows the test function to accept a fixture of either an  int  or a float  and to do the usual thing when a template is instantiated. Of course,\nyou don't  always  need to use  auto  here; if all of your fixtures inherit from\na common base type, you can use an ordinary lambda that takes a reference to the\nbase type.", 
            "title": "Parameterizing tests"
        }, 
        {
            "location": "/writing-tests/#transforming-fixture-types", 
            "text": "Earlier, we learned about  fixture factories . We can do\neven more with them, though: a fixture factory's  make T ()  can actually return any  type (including  void !), not just  T . This can be useful for more\ncomplex tests, like testing a container type with several different element\ntypes:  struct vector_factory {\n  template typename T \n  std::vector T  make() {\n    return {};\n  }\n};\n\nmettle::suite int, float  vector_suite( suite , vector_factory{}, [](auto  _) {\n  _.test( empty() , [](auto  vec) {\n    mettle::expect(vec.empty(), equal_to(true));\n  });\n});", 
            "title": "Transforming fixture types"
        }, 
        {
            "location": "/writing-tests/#type-only-fixtures", 
            "text": "As mentioned above, a fixture factory's  make T ()  can return  void . In this\ncase, the suite has no fixture whatsoever. This is primarily useful when you\nwant to parameterize on a list of types, but you don't want to automatically\ninstantiate the fixture object. The built-in fixture factory  type_only  handles\nthis for you. In particular, note the parameter-less test function:  mettle::suite int, float  type_only( suite , mettle::type_only, [](auto  _) {\n  _.test( empty() , []() {\n    /* ... */\n  });\n});", 
            "title": "Type-only fixtures"
        }, 
        {
            "location": "/writing-tests/#getting-the-parameterized-type", 
            "text": "In some cases, you may want to know the parameterized type, e.g. if you'd like\nto create your own instances of the object. You can retrieve this via the fixture_type  trait (or the  fixture_type_t  alias) like so:  mettle::suite int, float  param_type( suite , mettle::type_only, [](auto  _) {\n  using Fixture = mettle::fixture_type_t decltype(_) ;\n\n  _.test( my test , []() {\n    /* use Fixture here */\n  });\n});", 
            "title": "Getting the parameterized type"
        }, 
        {
            "location": "/writing-tests/#test-attributes", 
            "text": "For large projects with many tests, it can be useful to run only a subset of\nthem, instead of the entire collection. While splitting up tests by file can\nhelp, it doesn't allow for very precise control of what tests get run. Instead,\nyou can apply attributes to your tests (or whole suites!) and filter on them.", 
            "title": "Test attributes"
        }, 
        {
            "location": "/writing-tests/#the-skip-attribute", 
            "text": "mettle provides one built-in attribute:  mettle::skip . As the name implies,\nthis attribute causes a test to be skipped by default. This can be useful when a\ntest is broken, since the test runner will keep track of the skipped tests as a\nreminder that you need to go back and fix the test. You can also provide a\ncomment for the skipped test that will be shown in the test logs explaining why\nit was skipped.  For more information about how to use the  skip  attribute, see  Using\nAttributes  below.", 
            "title": "The skip attribute"
        }, 
        {
            "location": "/writing-tests/#defining-attributes", 
            "text": "In addition to the built-in  skip  attribute, you can define your own\nattributes. There are three basic kinds of attributes, differentiated by the\nnumber of values each can hold:  mettle::bool_attr , which holds 0 or 1 values; mettle::string_attr , which holds exactly 1 value; and  mettle::list_attr ,\nwhich holds 1 or more distinct values.  bool_attr s are somewhat special and can be given a default action\nwhen they're encountered (either  mettle::attr_action::run  or mettle::attr_action::skip ). As you might be able to guess, the predefined skip  attribute is just a  bool_attr  whose action is  attr_action::skip .  To define an attribute, you just need to create a global instance of one of the\naforementioned attribute kinds:  mettle::bool_attr slow( slow );\nmettle::bool_attr busted( busted , attr_action::skip);\nmettle::list_attr tags( tags );", 
            "title": "Defining attributes"
        }, 
        {
            "location": "/writing-tests/#using-attributes", 
            "text": "It's easy to apply attributes to your tests: simply create instances of each\nkind of attribute you want, and pass them to the test creation function\nimmediately after the test name:  _.test( my test , {mettle::skip, slow( takes too long ), tags( cat ,  goat )},\n       [](auto  fixture) { /* ... */ });  This creates a  mettle::attributes  object that gets stored alongside the test.\nAs you might notice,  bool_attrs  can be implicitly converted to an attribute\ninstance, but other types require you to call them to list their values.", 
            "title": "Using attributes"
        }, 
        {
            "location": "/writing-tests/#suite-attributes", 
            "text": "Like tests, whole suites can have attributes associated with them; these are\napplied the same way as for tests, and the list of attributes will automatically\nbe inherited by any children (tests or subsuites). The children can set their\nown attributes, and all the attributes in the hierarchy will be combined\ntogether for each test.  For  bool_attr s and  string_attr s, children with the same attribute as their\nparents will  override  the parent's attribute, but for  list_attr s, the\nvalues from the parent and child will be merged:  mettle::suite \nattr_suite( my suite , {mettle::skip( broken ), tags( cat )}, [](auto  _) {\n  _.test( my test , {slow, mettle::skip( fixme ), tags( dog )}, []() {\n    /* This test has the following attributes: slow, skip( fixme ), and\n       tags( cat ,  dog ). */\n  });\n});", 
            "title": "Suite attributes"
        }, 
        {
            "location": "/writing-tests/#mixing-fixture-factories-and-attributes", 
            "text": "At this point, you may be wondering how to specify  both  a fixture factory and\na set of attributes for suite. Since they're both optional arguments that appear\nbetween the suite's name and its creation function, which goes first?  The\nattributes always go first :  mettle::suite int \nthe_works( my complicated suite , {mettle::skip}, type_only, [](auto  _) {\n  /* ... */\n});  There's an easy rule to remember this: since attributes are a way of identifying\nthe suite, they go near the other identifier: the name. Likewise, fixture\nfactories affect how the suite is  executed , so they go near the creation\nfunction, which also affects its execution.", 
            "title": "Mixing fixture factories and attributes"
        }, 
        {
            "location": "/expectations/", 
            "text": "Expectations\n\n\nExpectations are a way of checking that the state of your code matches your\nexpectation, similar to an \nassert\n. If the expectation is met, then everything\nproceeds as normal. Otherwise, it throws an exception and aborts the current\ntest.\n\n\nDeclaring an expectation\n\n\nExpectations are easy to write. Just call \nmettle::expect\n with the \nactual\n\nvalue you'd like to test and a \nmatcher\n object. We'll look at matchers in\ndetail \nlater\n, but for now, let's just look at a simple matcher:\n\nmettle::equal_to(x)\n creates a matcher that will return \ntrue\n when the actual\nvalue passed to \nexpect\n is equal to \nx\n (according to the definition of \n==\n\nfor the type(s) in question).  Here it is all put together:\n\n\nmettle::expect(the_beast, mettle::equal_to(666));\n\n\n\n\nIf this expectation failed, you'd see something like the following logged to\nyour console (with the name of the failing \ntest case\n\npreceding it):\n\n\nexpected: 666\nactual:   123\n\n\n\n\nDescribing an expectation\n\n\nYou can also provide an description for an expectation to make it easier to\nfigure out what it was testing if you get a failure:\n\n\nmettle::expect(\nis 'to mega therion'?\n, the_beast, mettle::equal_to(666));\n\n\n\n\nIf this expectation fails, you'll see a message like the previous failure, but\nwith the description shown as well:\n\n\nis 'to mega therion'?\nexpected: 666\nactual:   123\n\n\n\n\nGetting the file and line number\n\n\nIf you'd like your expectation to print out its file and line number if it\nfailed, you can replace \nexpect\n in either example above with \nMETTLE_EXPECT\n.\nIn this case, you'll see output like:\n\n\nis 'to mega therion'? (test_file.cpp:13)\nexpected: 666\nactual:   123\n\n\n\n\nPrinting objects\n\n\nIn the examples above, the error output shows the expected and actual values.\nThis is easy for simple types, like integers, but what about complex\nuser-defined types? We could use the stream output operator \n (and indeed,\nthis option is supported), but there are times where you might want the debug\noutput to be different from the normal output. In addition, not every type has\n(or should have) an overload of \n.\n\n\nInstead, we use \nmettle::to_printable\n to ensure that our object will be\ndisplayed appropriately if we need to print it. This function returns an object\n(of unspecified type) that can be printed with the usual stream output operator.\nYou can also pass an iterator pair to \nto_printable\n to print the entire range.\nOf course, feel free to overload \nto_printable\n for your own types to show\nwhatever information you need to help debug test failures.\n\n\n\n\nNote\n\n\nMuch like overloaded operators and standard library functions like\n\nstd::swap\n, mettle uses argument-dependent lookup (ADL) to find the\nappropriate overload of \nto_printable\n. This is, of course, subject to all\nthe usual concerns with ADL, so keep this in mind when using \nto_printable\n.\n\n\n\n\nWhat is a matcher?\n\n\nAbove\n, we talked briefly about matchers and\nshowed how to use the equality matcher: \nmettle::equal_to(666)\n. Before we\ncontinue any further, we should define what exactly a matcher is. \nMatchers\n are\ncomposable functions that let you declare what you expect a value to be. The\ncomposability of matchers allows you to build complex expections from a\nrelatively small set of simple matchers. What's more, matchers automatically\nproduce human-readable descriptions of what exactly they're testing, freeing you\nfrom having to manually describe every expectation!\n\n\nIn addition, mettle comes with a collection of \nbuilt-in\nmatchers\n that can be used (or combined together) to\nperform most common tests. However, if these don't suffice, you can always\n\nwrite your own\n.\n\n\nHow matchers work\n\n\nThe internals of a matcher are actually pretty simple; they're just function\nobjects inheriting from \nmettle::matcher_tag\n and also providing a \ndesc()\n\nmember function that returns a string describing the matcher. All matchers can\nbe called with a single argument (the \nactual\n value in the expectation) and\nreturns whether the match was successful or not. To illustrate this more\nconcretely, the following defines a very simple matcher that checks if an \nint\n\nis 0:\n\n\nstruct int_zero : matcher_tag {\n  bool operator ()(int actual) const {\n    return actual == 0;\n  }\n\n  std::string desc() const {\n    return \nis 0\n;\n  }\n};\n\n\n\n\nComposing matchers\n\n\nMany of the built-in matchers, such as the \ncombinatoric\nmatchers\n, are \nhigher-order matchers\n. That\nis, they are created by taking other matchers as arguments. This allows you to\nbuild more complex matchers that test multiple aspects of an object at once. For\ninstance, you might want to check that a value is in the range [2, 4). With\nthe \nall\n matcher, this is easy:\n\n\nusing namespace mettle;\nexpect(x, all(greater_equal(2), less(4)));\n\n\n\n\nSimilarly, there are higher-order matchers that operate on\n\ncollections\n, allowing you, for example, to\ntest that all elements of a container meet a certain condition:\n\n\nusing namespace mettle;\nexpect(v, each(greater(0)));\n\n\n\n\nBy composing matchers together, you can express \nall\n the expected state of an\nobject in one place, making it clearer what exactly you're testing. Furthermore,\nsince all matchers provide a description of what they match, these higher-order\nmatchers can automatically tell you in human-readable form what they expect. For\ninstance, our test to check if a value is between 2 and 4 above might print\nsomething like this if it fails:\n\n\nexpected: all(\n=2, \n4)\nactual:   5\n\n\n\n\nMismatch messages\n\n\nAs we saw above, for most simple expectations, a failure will cause the\nmatcher's description to be printed out along with the actual value supplied to\n\nexpect\n. However, for some matchers, just seeing the actual value isn't very\nuseful. For example, with the \nthrown\n\nmatchers, you already know that the actual value is a function, so printing that\nfact out doesn't help.\n\n\nInstead, matchers can choose to return a mismatch message that provides a\nmorer useful, special-case description of the actual value (along with the usual\n\nbool\n to indicate if the matcher succeeded). For the \nthrown\n matcher, we can\nthen return a description of the exception the function \nactually\n threw (if\nany). In this case, the matcher returns a \nmettle::match_result\n object (a\n\nbool\n and a \nstd::string\n description) when called instead of a solitary\n\nbool\n. This makes the output for a failed test much nicer in this case:\n\n\nexpected: threw std::runtime_error(what: \nbad\n)\nactual:   threw std::runtime_error(what: \nworse\n)\n\n\n\n\nA \nmatch_result\n is implicity convertible to and from a \nbool\n, so matchers that\nreturn \nmatch_result\ns can easily be mixed with ones that return \nbool\ns. You\ncan also use the \n!\n operator to invert a \nmatch_result\n and preserve its\nmessage.\n\n\n\n\nNote\n\n\nDespite the name \"mismatch message\", it's useful to provide a message even\non success, since a successful match can easily become a mismatch simply by\nusing the \nis_not\n matcher.", 
            "title": "Expectations"
        }, 
        {
            "location": "/expectations/#expectations", 
            "text": "Expectations are a way of checking that the state of your code matches your\nexpectation, similar to an  assert . If the expectation is met, then everything\nproceeds as normal. Otherwise, it throws an exception and aborts the current\ntest.", 
            "title": "Expectations"
        }, 
        {
            "location": "/expectations/#declaring-an-expectation", 
            "text": "Expectations are easy to write. Just call  mettle::expect  with the  actual \nvalue you'd like to test and a  matcher  object. We'll look at matchers in\ndetail  later , but for now, let's just look at a simple matcher: mettle::equal_to(x)  creates a matcher that will return  true  when the actual\nvalue passed to  expect  is equal to  x  (according to the definition of  == \nfor the type(s) in question).  Here it is all put together:  mettle::expect(the_beast, mettle::equal_to(666));  If this expectation failed, you'd see something like the following logged to\nyour console (with the name of the failing  test case \npreceding it):  expected: 666\nactual:   123", 
            "title": "Declaring an expectation"
        }, 
        {
            "location": "/expectations/#describing-an-expectation", 
            "text": "You can also provide an description for an expectation to make it easier to\nfigure out what it was testing if you get a failure:  mettle::expect( is 'to mega therion'? , the_beast, mettle::equal_to(666));  If this expectation fails, you'll see a message like the previous failure, but\nwith the description shown as well:  is 'to mega therion'?\nexpected: 666\nactual:   123", 
            "title": "Describing an expectation"
        }, 
        {
            "location": "/expectations/#getting-the-file-and-line-number", 
            "text": "If you'd like your expectation to print out its file and line number if it\nfailed, you can replace  expect  in either example above with  METTLE_EXPECT .\nIn this case, you'll see output like:  is 'to mega therion'? (test_file.cpp:13)\nexpected: 666\nactual:   123", 
            "title": "Getting the file and line number"
        }, 
        {
            "location": "/expectations/#printing-objects", 
            "text": "In the examples above, the error output shows the expected and actual values.\nThis is easy for simple types, like integers, but what about complex\nuser-defined types? We could use the stream output operator   (and indeed,\nthis option is supported), but there are times where you might want the debug\noutput to be different from the normal output. In addition, not every type has\n(or should have) an overload of  .  Instead, we use  mettle::to_printable  to ensure that our object will be\ndisplayed appropriately if we need to print it. This function returns an object\n(of unspecified type) that can be printed with the usual stream output operator.\nYou can also pass an iterator pair to  to_printable  to print the entire range.\nOf course, feel free to overload  to_printable  for your own types to show\nwhatever information you need to help debug test failures.   Note  Much like overloaded operators and standard library functions like std::swap , mettle uses argument-dependent lookup (ADL) to find the\nappropriate overload of  to_printable . This is, of course, subject to all\nthe usual concerns with ADL, so keep this in mind when using  to_printable .", 
            "title": "Printing objects"
        }, 
        {
            "location": "/expectations/#what-is-a-matcher", 
            "text": "Above , we talked briefly about matchers and\nshowed how to use the equality matcher:  mettle::equal_to(666) . Before we\ncontinue any further, we should define what exactly a matcher is.  Matchers  are\ncomposable functions that let you declare what you expect a value to be. The\ncomposability of matchers allows you to build complex expections from a\nrelatively small set of simple matchers. What's more, matchers automatically\nproduce human-readable descriptions of what exactly they're testing, freeing you\nfrom having to manually describe every expectation!  In addition, mettle comes with a collection of  built-in\nmatchers  that can be used (or combined together) to\nperform most common tests. However, if these don't suffice, you can always write your own .", 
            "title": "What is a matcher?"
        }, 
        {
            "location": "/expectations/#how-matchers-work", 
            "text": "The internals of a matcher are actually pretty simple; they're just function\nobjects inheriting from  mettle::matcher_tag  and also providing a  desc() \nmember function that returns a string describing the matcher. All matchers can\nbe called with a single argument (the  actual  value in the expectation) and\nreturns whether the match was successful or not. To illustrate this more\nconcretely, the following defines a very simple matcher that checks if an  int \nis 0:  struct int_zero : matcher_tag {\n  bool operator ()(int actual) const {\n    return actual == 0;\n  }\n\n  std::string desc() const {\n    return  is 0 ;\n  }\n};", 
            "title": "How matchers work"
        }, 
        {
            "location": "/expectations/#composing-matchers", 
            "text": "Many of the built-in matchers, such as the  combinatoric\nmatchers , are  higher-order matchers . That\nis, they are created by taking other matchers as arguments. This allows you to\nbuild more complex matchers that test multiple aspects of an object at once. For\ninstance, you might want to check that a value is in the range [2, 4). With\nthe  all  matcher, this is easy:  using namespace mettle;\nexpect(x, all(greater_equal(2), less(4)));  Similarly, there are higher-order matchers that operate on collections , allowing you, for example, to\ntest that all elements of a container meet a certain condition:  using namespace mettle;\nexpect(v, each(greater(0)));  By composing matchers together, you can express  all  the expected state of an\nobject in one place, making it clearer what exactly you're testing. Furthermore,\nsince all matchers provide a description of what they match, these higher-order\nmatchers can automatically tell you in human-readable form what they expect. For\ninstance, our test to check if a value is between 2 and 4 above might print\nsomething like this if it fails:  expected: all( =2,  4)\nactual:   5", 
            "title": "Composing matchers"
        }, 
        {
            "location": "/expectations/#mismatch-messages", 
            "text": "As we saw above, for most simple expectations, a failure will cause the\nmatcher's description to be printed out along with the actual value supplied to expect . However, for some matchers, just seeing the actual value isn't very\nuseful. For example, with the  thrown \nmatchers, you already know that the actual value is a function, so printing that\nfact out doesn't help.  Instead, matchers can choose to return a mismatch message that provides a\nmorer useful, special-case description of the actual value (along with the usual bool  to indicate if the matcher succeeded). For the  thrown  matcher, we can\nthen return a description of the exception the function  actually  threw (if\nany). In this case, the matcher returns a  mettle::match_result  object (a bool  and a  std::string  description) when called instead of a solitary bool . This makes the output for a failed test much nicer in this case:  expected: threw std::runtime_error(what:  bad )\nactual:   threw std::runtime_error(what:  worse )  A  match_result  is implicity convertible to and from a  bool , so matchers that\nreturn  match_result s can easily be mixed with ones that return  bool s. You\ncan also use the  !  operator to invert a  match_result  and preserve its\nmessage.   Note  Despite the name \"mismatch message\", it's useful to provide a message even\non success, since a successful match can easily become a mismatch simply by\nusing the  is_not  matcher.", 
            "title": "Mismatch messages"
        }, 
        {
            "location": "/built-in-matchers/", 
            "text": "Built-in Matchers\n\n\nMettle comes with a set of general-purpose matchers that should cover the most\ncommon cases. We'll look at each of them below. The entire set of matchers can\nbe included via \n#include \nmettle/matchers.hpp\n, or you can include just the\ncategories you need by including the appropriate file (e.g.\n\n#include \nmettle/matchers/combinatoric.hpp\n).\n\n\nCore\n\n\nmettle/matchers/core.hpp\n\n\nanything()\n\n\nA matcher that always returns \ntrue\n. This is useful primarily as a placeholder,\ne.g. when you can't know for sure what an expected value is going to be, but you\nstill want to test it.\n\n\nis_not(\nmatcher\n)\n\n\nA matcher that negates another matcher.\n\n\ndescribe(\nmatcher\n, \ndesc\n)\n\n\nA matcher that overrides the description of another matcher. \ndesc\n is a string\ndescribing the resulting matcher. This can be useful for when the default\ndescription is unclear or overly-verbose.\n\n\nfilter(\nfunc\n, \nmatcher\n[, \ndesc\n])\n\n\nA matcher that filters the expected value through a function before passing it\nto another matcher. This helps when creating complex matchers that test multiple\nparts of a type, such as:\n\n\nall( filter([](auto \nx) { return x.first;  }, equal_to(\nfirst\n)),\n     filter([](auto \nx) { return x.second; }, greater(0)) );\n\n\n\n\nAdditionally, you may pass in a string for \ndesc\n, which will be added as a\nprefix to \nmatcher\n's description. This helps provide useful output explaining\nwhat exactly \nfunc\n is doing to the expected value.\n\n\nRelational\n\n\nmettle/matchers/relational.hpp\n\n\nequal_to(\nvalue\n)\n\n\nA matcher that returns \ntrue\n when the actual value is equal to \nvalue\n\naccording to the \n==\n operator.\n\n\n\n\nNote\n\n\nequal_to\n is also the \nimplicit matcher\n. Any time a matcher takes another\nmatcher as an argument, you can pass in a value, and it will be implicitly\nconverted to \nequal_to(value)\n. This doesn't work for the root matcher; you\nneed to explicitly say \nequal_to(value)\n in that case.\n\n\n\n\nnot_equal_to(\nvalue\n)\n\n\nA matcher that returns \ntrue\n when the actual value is not equal to \nvalue\n\naccording to the \n!=\n operator.\n\n\ngreater(\nvalue\n)\n\n\nA matcher that returns \ntrue\n when the actual value is greater than \nvalue\n\naccording to the \n operator.\n\n\ngreater_equal(\nvalue\n)\n\n\nA matcher that returns \ntrue\n when the actual value is greater than or equal to\n\nvalue\n according to the \n=\n operator.\n\n\nless(\nvalue\n)\n\n\nA matcher that returns \ntrue\n when the actual value is less than \nvalue\n\naccording to the \n operator.\n\n\nless_equal(\nvalue\n)\n\n\nA matcher that returns \ntrue\n when the actual value is less than or equal to\n\nvalue\n according to the \n=\n operator.\n\n\nArithmetic\n\n\nmettle/matchers/arithmetic.hpp\n\n\nnear_to(\nvalue\n[, \nepsilon\n])\n\n\nA matcher that returns \ntrue\n when the actual value is approximately equal to\n\nvalue\n, specifically when:\n\n\nauto mag = std::max\nT\n(std::abs(expected), std::abs(actual));\nstd::abs(actual - expected) \n= mag * epsilon;\n\n\n\n\nIf \nepsilon\n is not specified, it defaults to\n\nstd::numeric_limits\nT\n::epsilon() * 10\n.\n\n\n\n\nWarning\n\n\nAs with most functions that check if two floating point numbers are\napproximately equal, this matcher will likely fail if one of the values is\nzero. In that case, use \nnear_to_abs\n.\n\n\n\n\nnear_to_abs(\nvalue\n, \ntolerance\n)\n\n\nA matcher that returns \ntrue\n when the actual value is approximately equal to\n\nvalue\n, specifically when \nstd::abs(actual - expected) \n= tolerance\n.\n\n\nRegular expression\n\n\nmettle/matchers/regex.hpp\n\n\nregex_match(\nex\n[, \nsyntax\n, \nmatch\n])\n\n\nA matcher that returns \ntrue\n if the regex \nex\n matches the entirety of the\nactual value. If \nsyntax\n or \nmatch\n are specified, the matcher uses those for\nthe regex's syntax and match flags, respectively.\n\n\nregex_search(\nex\n[, \nsyntax\n, \nmatch\n])\n\n\nA matcher that returns \ntrue\n if the regex \nex\n matches a subsequence of the\nactual value. If \nsyntax\n or \nmatch\n are specified, the matcher uses those for\nthe regex's syntax and match flags, respectively.\n\n\n\n\nNote\n\n\nSince \nstd::regex\n objects don't provide access to a string representation\nof the expression, the \nex\n parameter in the above matchers should be a\nstring, not a regex. This allows the matcher to print the regex to the\nconsole if the matcher fails.\n\n\n\n\nCombinatoric\n\n\nmettle/matchers/combinatoric.hpp\n\n\nany(\nmatchers...\n)\n\n\nA matcher that returns \ntrue\n when \nany of\n its composed matchers are true.\n\n\nall(\nmatchers...\n)\n\n\nA matcher that returns \ntrue\n when \nall of\n its composed matchers are true.\n\n\nnone(\nmatchers...\n)\n\n\nA matcher that returns \ntrue\n when \nnone of\n its composed matchers are true.\n\n\nCollection\n\n\nmettle/matchers/collection.hpp\n\n\nmember(\nmatcher\n)\n\n\nA matcher that returns \ntrue\n when an item in a collection matches the composed\nmatcher.\n\n\neach(\nmatcher\n)\n\n\nA matcher that returns \ntrue\n when \nevery\n item in a collection matches the\ncomposed matcher.\n\n\neach(\nrange\n, \nmeta_matcher\n)\n\n\nA matcher that returns \ntrue\n when each item in a collection matches the\ncorresponding item in \nrange\n according to the matcher built from\n\nmeta_matcher\n. \nrange\n can be any iterable collection, including a\n\nstd::initializer_list\n. This is roughly equivalent to:\n\n\narray( meta_matcher(range[0]), meta_matcher(range[1]), ...\n       meta_matcher(range[n]) )\n\n\n\n\n\n\nWarning\n\n\nWhen \nmeta_matcher\n is a template function, be careful about how you pass it\nin. For instance, \nequal_to\nint\n will expect an rvalue-reference to an\n\nint\n. If \nrange\n is an lvalue, you'll need to pass \nequal_to\nconst int \n\ninstead.\n\n\n\n\neach(\nbegin\n, \nend\n, \nmeta_matcher\n)\n\n\nA matcher that returns \ntrue\n when each item in a collection matches the\ncorresponding item in the range [\nbegin\n, \nend\n) according to the matcher\nbuilt from \nmeta_matcher\n.\n\n\narray(\nmatchers...\n)\n\n\nA matcher that returns \ntrue\n when the \nith\n item in a collection matches the\n\nith\n composed matcher, \nand\n the number of items in the collection is equal to\nthe number of composed matchers.\n\n\ntuple(\nmatchers...\n)\n\n\nSimilar to \narray\n, but applies to tuples instead (or anything else with a\n\nstd::get\nI\n()\n overload). This matcher returns \ntrue\n when the \nith\n item in a\ntuple matches the \nith\n composed matcher. Since the size of a tuple can be\ndetermined at compile time, a length mismatch between the tuple and the number\nof composed matchers will cause a compiler error.\n\n\nsorted([\ncomparator\n])\n\n\nA matcher that returns \ntrue\n when the collection is sorted according to the\nbinary predicate \ncomparator\n (or the less-than operator if \ncomparator\n isn't\nsupplied).\n\n\npermutation(\nrange\n[, \npredicate\n])\n\n\nA matcher that returns \ntrue\n if a permutation of \nrange\n exists that equals\nthe collection according for the binary predicate \npredicate\n (or the equality\noperator if \npredicate\n isn't supplied).\n\n\npermutation(\nbegin\n, \nend\n[, \npredicate\n])\n\n\nA matcher that returns \ntrue\n if the range [\nbegin\n, \nend\n) is a permutation\nof the collection for the binary predicate \npredicate\n (or the equality operator\nif \npredicate\n isn't supplied).\n\n\nException\n\n\nmettle/matchers/exception.hpp\n\n\nException matchers work a bit differently from other matchers. Since we can't\ncatch an exception after the fact, we have to pass a function to our\nexpectation instead:\n\n\nexpect([]() { throw std::runtime_error(\nuh oh\n); },\n       thrown\nstd::runtime_error\n(\nuh oh\n));\n\n\n\n\nthrown\nType\n(\nwhat_matcher\n)\n\n\nA matcher that returns \ntrue\n if an exception of type \nType\n (or a subclass of\n\nType\n) is thrown and whose \nwhat()\n member function matches \nwhat_matcher\n.\n\n\nthrown\nType\n()\n\n\nA matcher that returns \ntrue\n if an exception of type \nType\n (or a subclass of\n\nType\n) is thrown; equivalent to: \nthrown\nType\n(anything())\n.\n\n\nthrown()\n\n\nA matcher that returns \ntrue\n if an exception of \nany\n type \nType\n is thrown.\n\n\nthrown_raw\nType\n(\nmatcher\n)\n\n\nA matcher that returns \ntrue\n if an exception of type \nType\n (or a subclass of\n\nType\n) is thrown and whose value matches \nmatcher\n.\n\n\nDeath\n\n\nmettle/matchers/death.hpp\n\n\n\n\nNote\n\n\nThese matchers are currently unusable on Windows. Sorry about that!\n\n\n\n\nThe most kvlt of all matchers, death matchers check that a function would cause\nthe process to terminate, either by signalling or by exiting. (These matchers\nwill fork a child process before calling the function so that the test\nframework doesn't terminate.) Like \nexception matchers\n,\ndeath matchers require a function to be passed to the expectation:\n\n\nexpect([]() { abort(); }, killed(SIGABRT));\n\n\n\n\nkilled([\nmatcher\n])\n\n\nA matcher that returns \ntrue\n if the function terminated the process via a\nsignal. If \nmatcher\n is specified, \nkilled\n will only return \ntrue\n if the\nsignal that was raised matches \nmatcher\n.\n\n\nexited([\nmatcher\n])\n\n\nA matcher that returns \ntrue\n if the function terminated the process by exiting\n(i.e. with \nexit\n, \n_exit\n, or \n_Exit\n). If \nmatcher\n is specified, \nexited\n\nwill only return \ntrue\n if the exit status matches \nmatcher\n.", 
            "title": "Built-in Matchers"
        }, 
        {
            "location": "/built-in-matchers/#built-in-matchers", 
            "text": "Mettle comes with a set of general-purpose matchers that should cover the most\ncommon cases. We'll look at each of them below. The entire set of matchers can\nbe included via  #include  mettle/matchers.hpp , or you can include just the\ncategories you need by including the appropriate file (e.g. #include  mettle/matchers/combinatoric.hpp ).", 
            "title": "Built-in Matchers"
        }, 
        {
            "location": "/built-in-matchers/#core", 
            "text": "mettle/matchers/core.hpp", 
            "title": "Core"
        }, 
        {
            "location": "/built-in-matchers/#anything", 
            "text": "A matcher that always returns  true . This is useful primarily as a placeholder,\ne.g. when you can't know for sure what an expected value is going to be, but you\nstill want to test it.", 
            "title": "anything()"
        }, 
        {
            "location": "/built-in-matchers/#is_notmatcher", 
            "text": "A matcher that negates another matcher.", 
            "title": "is_not(matcher)"
        }, 
        {
            "location": "/built-in-matchers/#describematcher-desc", 
            "text": "A matcher that overrides the description of another matcher.  desc  is a string\ndescribing the resulting matcher. This can be useful for when the default\ndescription is unclear or overly-verbose.", 
            "title": "describe(matcher, desc)"
        }, 
        {
            "location": "/built-in-matchers/#filterfunc-matcher-desc", 
            "text": "A matcher that filters the expected value through a function before passing it\nto another matcher. This helps when creating complex matchers that test multiple\nparts of a type, such as:  all( filter([](auto  x) { return x.first;  }, equal_to( first )),\n     filter([](auto  x) { return x.second; }, greater(0)) );  Additionally, you may pass in a string for  desc , which will be added as a\nprefix to  matcher 's description. This helps provide useful output explaining\nwhat exactly  func  is doing to the expected value.", 
            "title": "filter(func, matcher[, desc])"
        }, 
        {
            "location": "/built-in-matchers/#relational", 
            "text": "mettle/matchers/relational.hpp", 
            "title": "Relational"
        }, 
        {
            "location": "/built-in-matchers/#equal_tovalue", 
            "text": "A matcher that returns  true  when the actual value is equal to  value \naccording to the  ==  operator.   Note  equal_to  is also the  implicit matcher . Any time a matcher takes another\nmatcher as an argument, you can pass in a value, and it will be implicitly\nconverted to  equal_to(value) . This doesn't work for the root matcher; you\nneed to explicitly say  equal_to(value)  in that case.", 
            "title": "equal_to(value)"
        }, 
        {
            "location": "/built-in-matchers/#not_equal_tovalue", 
            "text": "A matcher that returns  true  when the actual value is not equal to  value \naccording to the  !=  operator.", 
            "title": "not_equal_to(value)"
        }, 
        {
            "location": "/built-in-matchers/#greatervalue", 
            "text": "A matcher that returns  true  when the actual value is greater than  value \naccording to the   operator.", 
            "title": "greater(value)"
        }, 
        {
            "location": "/built-in-matchers/#greater_equalvalue", 
            "text": "A matcher that returns  true  when the actual value is greater than or equal to value  according to the  =  operator.", 
            "title": "greater_equal(value)"
        }, 
        {
            "location": "/built-in-matchers/#lessvalue", 
            "text": "A matcher that returns  true  when the actual value is less than  value \naccording to the   operator.", 
            "title": "less(value)"
        }, 
        {
            "location": "/built-in-matchers/#less_equalvalue", 
            "text": "A matcher that returns  true  when the actual value is less than or equal to value  according to the  =  operator.", 
            "title": "less_equal(value)"
        }, 
        {
            "location": "/built-in-matchers/#arithmetic", 
            "text": "mettle/matchers/arithmetic.hpp", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/built-in-matchers/#near_tovalue-epsilon", 
            "text": "A matcher that returns  true  when the actual value is approximately equal to value , specifically when:  auto mag = std::max T (std::abs(expected), std::abs(actual));\nstd::abs(actual - expected)  = mag * epsilon;  If  epsilon  is not specified, it defaults to std::numeric_limits T ::epsilon() * 10 .   Warning  As with most functions that check if two floating point numbers are\napproximately equal, this matcher will likely fail if one of the values is\nzero. In that case, use  near_to_abs .", 
            "title": "near_to(value[, epsilon])"
        }, 
        {
            "location": "/built-in-matchers/#near_to_absvalue-tolerance", 
            "text": "A matcher that returns  true  when the actual value is approximately equal to value , specifically when  std::abs(actual - expected)  = tolerance .", 
            "title": "near_to_abs(value, tolerance)"
        }, 
        {
            "location": "/built-in-matchers/#regular-expression", 
            "text": "mettle/matchers/regex.hpp", 
            "title": "Regular expression"
        }, 
        {
            "location": "/built-in-matchers/#regex_matchex-syntax-match", 
            "text": "A matcher that returns  true  if the regex  ex  matches the entirety of the\nactual value. If  syntax  or  match  are specified, the matcher uses those for\nthe regex's syntax and match flags, respectively.", 
            "title": "regex_match(ex[, syntax, match])"
        }, 
        {
            "location": "/built-in-matchers/#regex_searchex-syntax-match", 
            "text": "A matcher that returns  true  if the regex  ex  matches a subsequence of the\nactual value. If  syntax  or  match  are specified, the matcher uses those for\nthe regex's syntax and match flags, respectively.   Note  Since  std::regex  objects don't provide access to a string representation\nof the expression, the  ex  parameter in the above matchers should be a\nstring, not a regex. This allows the matcher to print the regex to the\nconsole if the matcher fails.", 
            "title": "regex_search(ex[, syntax, match])"
        }, 
        {
            "location": "/built-in-matchers/#combinatoric", 
            "text": "mettle/matchers/combinatoric.hpp", 
            "title": "Combinatoric"
        }, 
        {
            "location": "/built-in-matchers/#anymatchers", 
            "text": "A matcher that returns  true  when  any of  its composed matchers are true.", 
            "title": "any(matchers...)"
        }, 
        {
            "location": "/built-in-matchers/#allmatchers", 
            "text": "A matcher that returns  true  when  all of  its composed matchers are true.", 
            "title": "all(matchers...)"
        }, 
        {
            "location": "/built-in-matchers/#nonematchers", 
            "text": "A matcher that returns  true  when  none of  its composed matchers are true.", 
            "title": "none(matchers...)"
        }, 
        {
            "location": "/built-in-matchers/#collection", 
            "text": "mettle/matchers/collection.hpp", 
            "title": "Collection"
        }, 
        {
            "location": "/built-in-matchers/#membermatcher", 
            "text": "A matcher that returns  true  when an item in a collection matches the composed\nmatcher.", 
            "title": "member(matcher)"
        }, 
        {
            "location": "/built-in-matchers/#eachmatcher", 
            "text": "A matcher that returns  true  when  every  item in a collection matches the\ncomposed matcher.", 
            "title": "each(matcher)"
        }, 
        {
            "location": "/built-in-matchers/#eachrange-meta_matcher", 
            "text": "A matcher that returns  true  when each item in a collection matches the\ncorresponding item in  range  according to the matcher built from meta_matcher .  range  can be any iterable collection, including a std::initializer_list . This is roughly equivalent to:  array( meta_matcher(range[0]), meta_matcher(range[1]), ...\n       meta_matcher(range[n]) )   Warning  When  meta_matcher  is a template function, be careful about how you pass it\nin. For instance,  equal_to int  will expect an rvalue-reference to an int . If  range  is an lvalue, you'll need to pass  equal_to const int  \ninstead.", 
            "title": "each(range, meta_matcher)"
        }, 
        {
            "location": "/built-in-matchers/#eachbegin-end-meta_matcher", 
            "text": "A matcher that returns  true  when each item in a collection matches the\ncorresponding item in the range [ begin ,  end ) according to the matcher\nbuilt from  meta_matcher .", 
            "title": "each(begin, end, meta_matcher)"
        }, 
        {
            "location": "/built-in-matchers/#arraymatchers", 
            "text": "A matcher that returns  true  when the  ith  item in a collection matches the ith  composed matcher,  and  the number of items in the collection is equal to\nthe number of composed matchers.", 
            "title": "array(matchers...)"
        }, 
        {
            "location": "/built-in-matchers/#tuplematchers", 
            "text": "Similar to  array , but applies to tuples instead (or anything else with a std::get I ()  overload). This matcher returns  true  when the  ith  item in a\ntuple matches the  ith  composed matcher. Since the size of a tuple can be\ndetermined at compile time, a length mismatch between the tuple and the number\nof composed matchers will cause a compiler error.", 
            "title": "tuple(matchers...)"
        }, 
        {
            "location": "/built-in-matchers/#sortedcomparator", 
            "text": "A matcher that returns  true  when the collection is sorted according to the\nbinary predicate  comparator  (or the less-than operator if  comparator  isn't\nsupplied).", 
            "title": "sorted([comparator])"
        }, 
        {
            "location": "/built-in-matchers/#permutationrange-predicate", 
            "text": "A matcher that returns  true  if a permutation of  range  exists that equals\nthe collection according for the binary predicate  predicate  (or the equality\noperator if  predicate  isn't supplied).", 
            "title": "permutation(range[, predicate])"
        }, 
        {
            "location": "/built-in-matchers/#permutationbegin-end-predicate", 
            "text": "A matcher that returns  true  if the range [ begin ,  end ) is a permutation\nof the collection for the binary predicate  predicate  (or the equality operator\nif  predicate  isn't supplied).", 
            "title": "permutation(begin, end[, predicate])"
        }, 
        {
            "location": "/built-in-matchers/#exception", 
            "text": "mettle/matchers/exception.hpp  Exception matchers work a bit differently from other matchers. Since we can't\ncatch an exception after the fact, we have to pass a function to our\nexpectation instead:  expect([]() { throw std::runtime_error( uh oh ); },\n       thrown std::runtime_error ( uh oh ));", 
            "title": "Exception"
        }, 
        {
            "location": "/built-in-matchers/#throwntypewhat_matcher", 
            "text": "A matcher that returns  true  if an exception of type  Type  (or a subclass of Type ) is thrown and whose  what()  member function matches  what_matcher .", 
            "title": "thrown&lt;Type&gt;(what_matcher)"
        }, 
        {
            "location": "/built-in-matchers/#throwntype", 
            "text": "A matcher that returns  true  if an exception of type  Type  (or a subclass of Type ) is thrown; equivalent to:  thrown Type (anything()) .", 
            "title": "thrown&lt;Type&gt;()"
        }, 
        {
            "location": "/built-in-matchers/#thrown", 
            "text": "A matcher that returns  true  if an exception of  any  type  Type  is thrown.", 
            "title": "thrown()"
        }, 
        {
            "location": "/built-in-matchers/#thrown_rawtypematcher", 
            "text": "A matcher that returns  true  if an exception of type  Type  (or a subclass of Type ) is thrown and whose value matches  matcher .", 
            "title": "thrown_raw&lt;Type&gt;(matcher)"
        }, 
        {
            "location": "/built-in-matchers/#death", 
            "text": "mettle/matchers/death.hpp   Note  These matchers are currently unusable on Windows. Sorry about that!   The most kvlt of all matchers, death matchers check that a function would cause\nthe process to terminate, either by signalling or by exiting. (These matchers\nwill fork a child process before calling the function so that the test\nframework doesn't terminate.) Like  exception matchers ,\ndeath matchers require a function to be passed to the expectation:  expect([]() { abort(); }, killed(SIGABRT));", 
            "title": "Death"
        }, 
        {
            "location": "/built-in-matchers/#killedmatcher", 
            "text": "A matcher that returns  true  if the function terminated the process via a\nsignal. If  matcher  is specified,  killed  will only return  true  if the\nsignal that was raised matches  matcher .", 
            "title": "killed([matcher])"
        }, 
        {
            "location": "/built-in-matchers/#exitedmatcher", 
            "text": "A matcher that returns  true  if the function terminated the process by exiting\n(i.e. with  exit ,  _exit , or  _Exit ). If  matcher  is specified,  exited \nwill only return  true  if the exit status matches  matcher .", 
            "title": "exited([matcher])"
        }, 
        {
            "location": "/writing-matchers/", 
            "text": "Writing Your Own Matchers\n\n\nmettle is designed to make it easy to write your own matchers to complement the\nbuilt-in suite of matchers. This makes it easier to test the state of objects\nwith complex properties. Once created, user-defined matchers can be composed as\nnormal with built-in matchers as you'd expect.\n\n\nHelper functions\n\n\nmake_matcher(\nfunction\n, \ndesc\n)\n\n\nThe easiest way to create your own matcher is with the \nmake_matcher\n function.\nThis takes two parameters: first, a function object that accepts a value of any\ntype, and returns a \nbool\n (with \ntrue\n naturally meaning a successful match);\nand second, a string describing the matcher.\n\n\nmake_matcher\n returns a \nbasic_matcher\nvoid, F\n, where \nF\n is the type of the\nfunction, but it's easier to just deduce the return type. For instance, here's a\nsimple matcher that returns \ntrue\n when the actual value is 4:\n\n\nauto match_four() {\n  return make_matcher([](const auto \nvalue) -\n bool {\n    return value == 4;\n  }, \n== 4\n);\n}\n\n\n\n\nmake_matcher(\ncapture\n, \nfunction\n, \nprefix\n)\n\n\nYou can also \ncapture\n a value to use with your matcher; while you certainly\n\ncan\n capture the value via a lambda, passing the variable directly to\n\nmake_matcher\n allows it to be printed automatically when \ndesc()\n is called. In\nthis overload, \nfunction\n works as above, except that it takes a second argument\nfor the captured object. The final argument, \nprefix\n, is a string that will be\nprepended to the printed form of \ncapture\n.\n\n\nThis overload of \nmake_matcher\n returns a \nbasic_matcher\nT, F\n, where \nT\n is\nthe type of the capture and \nF\n is the type of the function. Again, it's easier\nto just deduce the return type. Here's an example of a matcher that returns\n\ntrue\n when two numbers are off by one:\n\n\ntemplate\ntypename T\n\nauto off_by_one(T \nexpected) {\n  return make_matcher(\n    std::forward\nT\n(expected),\n    [](const auto \nactual, const auto \nexpected) -\n bool {\n      auto x = std::minmax\nT\n(actual, expected);\n      return x.second - x.first == 1;\n    }, \noff by 1 from \n\n  );\n}\n\n\n\n\nensure_matcher(\nthing\n)\n\n\nSometimes, a matcher should be able to accept other matchers as an argument.\nHowever, we also typically want to be able to pass in arbitrary objects as a\nshorthand to implicitly call the \nequal_to\n matcher. In this case, we'd use\n\nensure_matcher\n.\n\n\nensure_matcher\n wraps an object with the \nequal_to\n matcher, or returns the\npassed-in matcher if the object is already a matcher. As an example, let's\ncreate a matcher that returns \ntrue\n if exactly one of its arguments is \ntrue\n:\n\n\ntemplate\ntypename T\n\nauto either(T \na, T \nb) {\n  auto a_matcher = ensure_matcher(std::forward\nT\n(a));\n  auto b_matcher = ensure_matcher(std::forward\nT\n(b));\n\n  return make_matcher([a_matcher, b_matcher](const auto \nvalue) -\n bool {\n    return a_matcher(value) ^ b_matcher(value);\n  }, a_matcher.desc() + \n xor \n + b_matcher.desc());\n}\n\n\n\n\nStarting from scratch\n\n\nFor particularly complex matchers, \nmake_matcher\n may not provide much value. In\nthese cases, you can instead build your own matcher from scratch. First, and\nmost importantly, all matchers must inherit from \nmatcher_tag\n. This removes any\nambiguity between actual matchers and types that just have a similar interface.\n\n\nAs the previous section hints at, a matcher must also have a const overloaded\n\noperator ()\n that takes a value of any type and returns a \nbool\n, and a const\n\ndesc\n function that returns a string description of the matcher.\n\n\nA matcher made from scratch isn't much more complex than one made using the\nhelper functions above; most of the complexity will come from the behaviors you\ndefine. Here's a simple example that \nnever\n returns \ntrue\n:\n\n\nstruct nothing : matcher_tag {\n  template\ntypename T\n\n  bool operator ()(const U \nvalue) const {\n    return false;\n  }\n\n  std::string desc() const {\n    return \nnothing\n;\n  }\n};\n\n\n\n\nFurther examples\n\n\nNaturally, many more examples of matchers can be found in mettle's own \nsource\ncode\n. Feel\nfree to consult these to get some ideas for how to implement your own matchers!", 
            "title": "Writing Your Own Matchers"
        }, 
        {
            "location": "/writing-matchers/#writing-your-own-matchers", 
            "text": "mettle is designed to make it easy to write your own matchers to complement the\nbuilt-in suite of matchers. This makes it easier to test the state of objects\nwith complex properties. Once created, user-defined matchers can be composed as\nnormal with built-in matchers as you'd expect.", 
            "title": "Writing Your Own Matchers"
        }, 
        {
            "location": "/writing-matchers/#helper-functions", 
            "text": "", 
            "title": "Helper functions"
        }, 
        {
            "location": "/writing-matchers/#make_matcherfunction-desc", 
            "text": "The easiest way to create your own matcher is with the  make_matcher  function.\nThis takes two parameters: first, a function object that accepts a value of any\ntype, and returns a  bool  (with  true  naturally meaning a successful match);\nand second, a string describing the matcher.  make_matcher  returns a  basic_matcher void, F , where  F  is the type of the\nfunction, but it's easier to just deduce the return type. For instance, here's a\nsimple matcher that returns  true  when the actual value is 4:  auto match_four() {\n  return make_matcher([](const auto  value) -  bool {\n    return value == 4;\n  },  == 4 );\n}", 
            "title": "make_matcher(function, desc)"
        }, 
        {
            "location": "/writing-matchers/#make_matchercapture-function-prefix", 
            "text": "You can also  capture  a value to use with your matcher; while you certainly can  capture the value via a lambda, passing the variable directly to make_matcher  allows it to be printed automatically when  desc()  is called. In\nthis overload,  function  works as above, except that it takes a second argument\nfor the captured object. The final argument,  prefix , is a string that will be\nprepended to the printed form of  capture .  This overload of  make_matcher  returns a  basic_matcher T, F , where  T  is\nthe type of the capture and  F  is the type of the function. Again, it's easier\nto just deduce the return type. Here's an example of a matcher that returns true  when two numbers are off by one:  template typename T \nauto off_by_one(T  expected) {\n  return make_matcher(\n    std::forward T (expected),\n    [](const auto  actual, const auto  expected) -  bool {\n      auto x = std::minmax T (actual, expected);\n      return x.second - x.first == 1;\n    },  off by 1 from  \n  );\n}", 
            "title": "make_matcher(capture, function, prefix)"
        }, 
        {
            "location": "/writing-matchers/#ensure_matcherthing", 
            "text": "Sometimes, a matcher should be able to accept other matchers as an argument.\nHowever, we also typically want to be able to pass in arbitrary objects as a\nshorthand to implicitly call the  equal_to  matcher. In this case, we'd use ensure_matcher .  ensure_matcher  wraps an object with the  equal_to  matcher, or returns the\npassed-in matcher if the object is already a matcher. As an example, let's\ncreate a matcher that returns  true  if exactly one of its arguments is  true :  template typename T \nauto either(T  a, T  b) {\n  auto a_matcher = ensure_matcher(std::forward T (a));\n  auto b_matcher = ensure_matcher(std::forward T (b));\n\n  return make_matcher([a_matcher, b_matcher](const auto  value) -  bool {\n    return a_matcher(value) ^ b_matcher(value);\n  }, a_matcher.desc() +   xor   + b_matcher.desc());\n}", 
            "title": "ensure_matcher(thing)"
        }, 
        {
            "location": "/writing-matchers/#starting-from-scratch", 
            "text": "For particularly complex matchers,  make_matcher  may not provide much value. In\nthese cases, you can instead build your own matcher from scratch. First, and\nmost importantly, all matchers must inherit from  matcher_tag . This removes any\nambiguity between actual matchers and types that just have a similar interface.  As the previous section hints at, a matcher must also have a const overloaded operator ()  that takes a value of any type and returns a  bool , and a const desc  function that returns a string description of the matcher.  A matcher made from scratch isn't much more complex than one made using the\nhelper functions above; most of the complexity will come from the behaviors you\ndefine. Here's a simple example that  never  returns  true :  struct nothing : matcher_tag {\n  template typename T \n  bool operator ()(const U  value) const {\n    return false;\n  }\n\n  std::string desc() const {\n    return  nothing ;\n  }\n};", 
            "title": "Starting from scratch"
        }, 
        {
            "location": "/writing-matchers/#further-examples", 
            "text": "Naturally, many more examples of matchers can be found in mettle's own  source\ncode . Feel\nfree to consult these to get some ideas for how to implement your own matchers!", 
            "title": "Further examples"
        }, 
        {
            "location": "/developer/", 
            "text": "Developer Guide\n\n\nIf you're looking to learn about how mettle actually works, you've come to the\nright place! This developer guide will describe mettle's internals and how\neverything fits together.\n\n\nRunner\n\n\nmettle's structure is a bit different from other test frameworks. First, like\nsome other test frameworks, individual (user-written) test files link to a\nshared library (\nlibmettle.so\n / \nmettle.dll\n) to pull in common driver code.\n\n\nHowever, in addition, the \nmettle\n test driver can be used to aggregate the\nresults of multiple test files. This lets you put your tests into multiple,\nseparate binaries to reduce compilation time and allow different kinds of tests\nto be run all at once (e.g. normal unit tests and compilation-failure tests).\n\n\nSubprocesses\n\n\nWhen running tests, mettle makes extensive use of subprocesses to isolate tests\nas much as possible. First, the \nmettle\n driver creates a subprocess for each\nindividual test binary, and these in turn (by default) create a subprocess for\neach test in the file. This ensures that no one test can crash the entire\nframework. However, the particulars differ between POSIX systems and Windows.\n\n\nPOSIX\n\n\nWhen the individual test binary forks for a specific test, the \ntest process\n is\nalso set as the process group leader for a new process group. This ensures\nthat any subprocesses it spawns can be killed after the main process finishes.\n\n\nAdditionally, if tests are set to time out after a certain period, two more\nsubprocesses are forked for each test: a \nmonitor process\n and a \ntimer\nprocess\n. The monitor process forks both the timer process and the actual test\nprocess and waits for the first one to finish. The timer process automatically\nexits after the timeout expires, and if it exits before the test process, the\nmonitor process kills the test and sends a message that it timed out.\n\n\nYou might be thinking, \"why not just use \nalarm(2)\n or \nsetitimer(2)\n instead of\nforking two extra times?\" However, this would interact poorly with tests that\nrely on functions like \nsleep(3)\n. Hence, in the interest of maximum isolation\nof the test code, the timer is implemented as a subprocess. Likewise, running\nthe timer in the parent process requires greater care when handling signals. In\nany case, the current method has the significant benefit of being entirely\ntransparent to the parent process.\n\n\nWindows\n\n\nSince Windows is unable to fork a process, when the individual test binary\ncreates a subprocess for a test, it simply reruns itself with a different set of\ncommand-line arguments, indicating that only a specific test should be run. This\nsubprocess is immediately placed into a new job, ensuring that \u2013 like the POSIX\nversion's process groups \u2013 any subprocesses it spawns can be killed after the\nmain process finishes.\n\n\nUnlike the POSIX version, if tests are set to time out, we simply create a timer\nevent and wait for it while we're waiting for the test process to end. If the\ntimer's event fires first, we know to kill the test process. Since the timer is\nrun in the parent process, this provides the same level of isolation as the\nPOSIX version, but at the expense of some extra management; the parent process\nmust now pay specific attention to the timer event instead of assuming that its\nchild process will handle it.\n\n\nSuites\n\n\nWhen creating a test suite, the most important argument to pass is the \ncreation\nfunction\n (conventionally a generic lambda). This function takes a\n\nsuite_builder\n (or a \nsubsuite_builder\n for subsuites). These are both template\nclasses that let the user add tests or subsuites to the given suite.\n\n\nOnce the creation function returns, the suite is compiled into a\n\nrunnable_suite\n (subsuites, however, are merely compiled into an intermediary\nform and stored in its parent's \n(sub)suite_builder\n instance). When the parent\nis compiled, the subsuite and all of its tests are compiled as well, until it\ngets to the root suite, at which point all tests and subsuites are\nfully-compiled.\n\n\nIf using the global \nsuite\n or \nbasic_suite\n types, once the suite is\nfully-compiled, it gets added to a global list of suites, held in\n\ndetail::all_suites()\n (subsuites, however, are contained within their parents).\nThis list is then used by the test driver to run all the tests.", 
            "title": "Developer Guide"
        }, 
        {
            "location": "/developer/#developer-guide", 
            "text": "If you're looking to learn about how mettle actually works, you've come to the\nright place! This developer guide will describe mettle's internals and how\neverything fits together.", 
            "title": "Developer Guide"
        }, 
        {
            "location": "/developer/#runner", 
            "text": "mettle's structure is a bit different from other test frameworks. First, like\nsome other test frameworks, individual (user-written) test files link to a\nshared library ( libmettle.so  /  mettle.dll ) to pull in common driver code.  However, in addition, the  mettle  test driver can be used to aggregate the\nresults of multiple test files. This lets you put your tests into multiple,\nseparate binaries to reduce compilation time and allow different kinds of tests\nto be run all at once (e.g. normal unit tests and compilation-failure tests).", 
            "title": "Runner"
        }, 
        {
            "location": "/developer/#subprocesses", 
            "text": "When running tests, mettle makes extensive use of subprocesses to isolate tests\nas much as possible. First, the  mettle  driver creates a subprocess for each\nindividual test binary, and these in turn (by default) create a subprocess for\neach test in the file. This ensures that no one test can crash the entire\nframework. However, the particulars differ between POSIX systems and Windows.", 
            "title": "Subprocesses"
        }, 
        {
            "location": "/developer/#posix", 
            "text": "When the individual test binary forks for a specific test, the  test process  is\nalso set as the process group leader for a new process group. This ensures\nthat any subprocesses it spawns can be killed after the main process finishes.  Additionally, if tests are set to time out after a certain period, two more\nsubprocesses are forked for each test: a  monitor process  and a  timer\nprocess . The monitor process forks both the timer process and the actual test\nprocess and waits for the first one to finish. The timer process automatically\nexits after the timeout expires, and if it exits before the test process, the\nmonitor process kills the test and sends a message that it timed out.  You might be thinking, \"why not just use  alarm(2)  or  setitimer(2)  instead of\nforking two extra times?\" However, this would interact poorly with tests that\nrely on functions like  sleep(3) . Hence, in the interest of maximum isolation\nof the test code, the timer is implemented as a subprocess. Likewise, running\nthe timer in the parent process requires greater care when handling signals. In\nany case, the current method has the significant benefit of being entirely\ntransparent to the parent process.", 
            "title": "POSIX"
        }, 
        {
            "location": "/developer/#windows", 
            "text": "Since Windows is unable to fork a process, when the individual test binary\ncreates a subprocess for a test, it simply reruns itself with a different set of\ncommand-line arguments, indicating that only a specific test should be run. This\nsubprocess is immediately placed into a new job, ensuring that \u2013 like the POSIX\nversion's process groups \u2013 any subprocesses it spawns can be killed after the\nmain process finishes.  Unlike the POSIX version, if tests are set to time out, we simply create a timer\nevent and wait for it while we're waiting for the test process to end. If the\ntimer's event fires first, we know to kill the test process. Since the timer is\nrun in the parent process, this provides the same level of isolation as the\nPOSIX version, but at the expense of some extra management; the parent process\nmust now pay specific attention to the timer event instead of assuming that its\nchild process will handle it.", 
            "title": "Windows"
        }, 
        {
            "location": "/developer/#suites", 
            "text": "When creating a test suite, the most important argument to pass is the  creation\nfunction  (conventionally a generic lambda). This function takes a suite_builder  (or a  subsuite_builder  for subsuites). These are both template\nclasses that let the user add tests or subsuites to the given suite.  Once the creation function returns, the suite is compiled into a runnable_suite  (subsuites, however, are merely compiled into an intermediary\nform and stored in its parent's  (sub)suite_builder  instance). When the parent\nis compiled, the subsuite and all of its tests are compiled as well, until it\ngets to the root suite, at which point all tests and subsuites are\nfully-compiled.  If using the global  suite  or  basic_suite  types, once the suite is\nfully-compiled, it gets added to a global list of suites, held in detail::all_suites()  (subsuites, however, are contained within their parents).\nThis list is then used by the test driver to run all the tests.", 
            "title": "Suites"
        }, 
        {
            "location": "/license/", 
            "text": "License\n\n\nBSD 3-clause license\n\n\nCopyright (c) 2014, Jim Porter\nAll rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.\n\n\n\n\n\n\nRedistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.\n\n\n\n\n\n\nNeither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\n\n\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", 
            "title": "License"
        }, 
        {
            "location": "/license/#license", 
            "text": "", 
            "title": "License"
        }, 
        {
            "location": "/license/#bsd-3-clause-license", 
            "text": "Copyright (c) 2014, Jim Porter\nAll rights reserved.  Redistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:    Redistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer.    Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation and/or\nother materials provided with the distribution.    Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", 
            "title": "BSD 3-clause license"
        }
    ]
}