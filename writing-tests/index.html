<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Writing Tests - mettle</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/base.css" rel="stylesheet">
        <link href="../css/extra.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]--> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="..">mettle</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="..">Home</a>
                    </li>
                    <li >
                        <a href="../install/">Installation</a>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">User Guide <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../tutorial/">Tutorial</a>
</li>
                            
<li >
    <a href="../running-tests/">Running Tests</a>
</li>
                            
<li class="active">
    <a href="./">Writing Tests</a>
</li>
                            
<li >
    <a href="../expectations/">Expectations</a>
</li>
                            
<li >
    <a href="../built-in-matchers/">Built-in Matchers</a>
</li>
                            
<li >
    <a href="../writing-matchers/">Writing Your Own Matchers</a>
</li>
                        </ul>
                    </li>
                    <li >
                        <a href="../developer/">Developer Guide</a>
                    </li>
                    <li >
                        <a href="../license/">License</a>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../running-tests/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../expectations/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/jimporter/mettle/">
                                <i class="fa fa-github"></i>GitHub
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#writing-tests">Writing Tests</a></li>
            <li><a href="#defining-suites">Defining suites</a></li>
            <li><a href="#setup-and-teardown">Setup and teardown</a></li>
            <li><a href="#subsuites">Subsuites</a></li>
            <li><a href="#fixtures">Fixtures</a></li>
            <li><a href="#parameterizing-tests">Parameterizing tests</a></li>
            <li><a href="#test-attributes">Test attributes</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="writing-tests">Writing Tests<a class="headerlink" href="#writing-tests" title="Permanent link">§</a></h1>
<p>Below, we'll look at how test files are structured, how to create the tests
themselves, and how to group them together to perform higher-level operations on
them. Throughout this page, we'll assume that the following appears at the
beginning of our examples:</p>
<pre><code class="c++">#include &lt;mettle.hpp&gt;
</code></pre>

<p>This includes <em>all</em> the headers necessary to use mettle. Alternately, you can
<code>#include &lt;mettle/header_only.hpp&gt;</code> if you prefer to use mettle without
compiling <code>libmettle.so</code> and the <code>mettle</code> universal driver.</p>
<p>If you'd rather include a smaller subset of headers, e.g. to improve compilation
speeds, you'll need the following to define tests and suites:</p>
<pre><code class="c++">#include &lt;mettle/suite.hpp&gt;

// Choose only one of these:
#include &lt;mettle/driver/lib_driver.hpp&gt;    // The driver to go with libmettle.so
#include &lt;mettle/driver/header_driver.hpp&gt; // The header-only driver
</code></pre>

<h2 id="defining-suites">Defining suites<a class="headerlink" href="#defining-suites" title="Permanent link">§</a></h2>
<p>In mettle, all tests are grouped by suites. Suites are generally defined as
global variables (we'll see more ways to define suites later), and take two
arguments in the constructor: a string name, and a callback function taking a
reference to a <code>mettle::suite_builder&lt;mettle::expectation_failure&gt;</code>. Generally,
we just define the callback as a generic lambda:</p>
<pre><code class="c++">mettle::suite&lt;&gt; my_suite(&quot;my suite&quot;, [](auto &amp;_) {
  /* ... */
});
</code></pre>

<p>If you don't plan to use mettle's <a href="../expectations/">expectations</a> for checking
program state, you can replace <code>mettle::suite&lt;&gt;</code> with
<code>mettle::basic_suite&lt;my_exception&gt;</code> to create a test suite using your own
exception type as the "canonical" exception.</p>
<h3 id="tests">Tests<a class="headerlink" href="#tests" title="Permanent link">§</a></h3>
<p>While we have a suite now, we still need to define some tests. Tests are,
without a doubt, the most important part of a <em>test</em> suite. We define our tests
inside our suite's callback function, using the <code>suite_builder</code> passed into it.
Like our suite, each test takes two arguments: a string name, and a callback
function defining the test. However, the test's callback takes no arguments:</p>
<pre><code class="c++">mettle::suite&lt;&gt; my_suite(&quot;my suite&quot;, [](auto &amp;_) {
  _.test(&quot;my test&quot;, []() {
    /* ... */
  });
});
</code></pre>

<p>Inside the test's callback function, we can write our actual test. If our code
throws an exception, the test will fail; otherwise, it passes. Most of your
tests should use <em><a href="../expectations/">expectations</a></em> (similar to assertions) to
perform the actual tests. Expectations provide informative error messages if any
part of your test fails.</p>
<h2 id="setup-and-teardown">Setup and teardown<a class="headerlink" href="#setup-and-teardown" title="Permanent link">§</a></h2>
<p>Sometimes, you'll have a bunch of tests that all have the same setup and
teardown code. Test fixtures let you do this (mostly) automatically. If a test
suite has a <code>setup</code> or <code>teardown</code> function set, they'll run before (or after)
each test in the suite:</p>
<pre><code class="c++">mettle::suite&lt;&gt; with_setup(&quot;my suite&quot;, [](auto &amp;_) {
  _.setup([]() {
    /* ... */
  });

  _.teardown([]() {
    /* ... */
  });

  _.test(&quot;my test&quot;, []() {
    /* ... */
  });
});
</code></pre>

<h2 id="subsuites">Subsuites<a class="headerlink" href="#subsuites" title="Permanent link">§</a></h2>
<p>When testing something particularly complex, you might find it useful to group
test suites together. You can do this by creating a subsuite inside a parent
suite:</p>
<pre><code class="c++">mettle::suite&lt;&gt; with_subsuites(&quot;suite with subsuites&quot;, [](auto &amp;_) {
  _.subsuite(&quot;subsuite&quot;, [](auto &amp;_) {
    _.test(&quot;my subtest&quot;, []() {
      /* ... */
    });
  });
});
</code></pre>

<p>You might have noticed above that, unlike for the root suite, our subsuite
doesn't contain an empty template parameter list (read: there's no <code>&lt;&gt;</code>). Since
<code>subsuite</code> is just a member function, the angle brackets aren't necessary, but
what if you want to supply a fixture for your subsuite? That's where it gets a
bit more complex. As you may recall, our suite's callback uses a generic lambda,
and so <code>_</code> is a <em>dependent type</em>. Template member functions of a dependent type
must be prefixed with the <code>template</code> keyword, like so:</p>
<pre><code class="c++">_.template subsuite&lt;int&gt;(&quot;subsuite&quot;, [](auto &amp;_) {
  /* ... */
});
</code></pre>

<p>However, this is rather ugly. To eliminate the <code>template</code> keyword, we could
either redefine our lambda to no longer be generic, or just use the
<code>mettle::subsuite</code> helper:</p>
<pre><code class="c++">mettle::subsuite&lt;&gt;(_, &quot;subsuite&quot;, [](auto &amp;_) {
  /* ... */
});
</code></pre>

<h3 id="nested-setup-and-teardown">Nested setup and teardown<a class="headerlink" href="#nested-setup-and-teardown" title="Permanent link">§</a></h3>
<p>As you might imagine, a test in a subsuite uses not only the subsuite's setup
and teardown functions, but inherits the parent suite's as well (and so on up
the tree). When executing a test in a subsuite, the test runner will walk down
the suite hierarchy, calling each setup function in turn before running the
test. After finishing the test, it will walk back up the tree calling each
teardown function.</p>
<p>For a two-level hierarchy, this is what would happen for each test in the
subsuite:</p>
<ol>
<li>Call the parent suite's setup function (if defined).</li>
<li>Call the subsuite's setup function (if defined).</li>
<li>Run the test function</li>
<li>Call the subsuite's teardown function (if defined).</li>
<li>Call the parent suite's teardown function (if defined).</li>
</ol>
<h2 id="fixtures">Fixtures<a class="headerlink" href="#fixtures" title="Permanent link">§</a></h2>
<p>Setup and teardown functions are of limited use without fixtures. Fixtures allow
you to safely write multiple, independent tests that test the same object. Each
test gets its own instance of the fixture, preventing it from affecting any of
the other tests. A fixture's lifetime is as follows:</p>
<ol>
<li>Constructor the fixture using the default constructor.</li>
<li>Pass the fixture by reference to the setup function (if defined).</li>
<li>Pass the fixture by reference to the test function.</li>
<li>Pass the fixture by reference to the teardown function (if defined).</li>
<li>Destruct the fixture.</li>
</ol>
<p>Declaring a fixture is simple. Just pass the type of your fixture in the
template parameters of your <code>mettle::suite</code> object:</p>
<pre><code class="c++">struct my_fixture {
  int i;
};

mettle::suite&lt;my_fixture&gt; with_fixture(&quot;suite with a fixture&quot;, [](auto &amp;_) {
  _.setup([](my_fixture &amp;f) {
    f.i = 1;
  });

  _.test(&quot;test my fixture&quot;, [](my_fixture &amp;f) {
    mettle::expect(f.i, equal_to(1));
  });
});
</code></pre>

<p>Astute readers will notice that a test fixture could easily be used to replace
the <code>setup</code> and <code>teardown</code> functions by using RAII. However, both options are
supported, since it's often simpler to write a setup/teardown code than to write
a less-flexible helper class. For instance, your fixture might be a database
object from your production code that you want to add some test records to for
testing. Rather than wrapping the database in a helper, you can just add the
test records in <code>setup</code>.</p>
<p>Sometimes, the default constructor for a fixture isn't appropriate. In these
cases, you can use <a href="#fixture-factories">fixture factories</a>, discussed below.</p>
<h3 id="nested-fixtures">Nested fixtures<a class="headerlink" href="#nested-fixtures" title="Permanent link">§</a></h3>
<p>Like the nested setup and teardown functions, test fixtures are also
inherited in subsuites. This allows a parent suite to handle common fixtures for
a bunch of subsuites, reducing code duplication:</p>
<pre><code class="c++">mettle::suite&lt;int&gt; nested_fixtures(&quot;suite with subsuites&quot;, [](auto &amp;_) {
  _.setup([](int &amp;i) {
    i = 1;
  });

  _.test(&quot;my parent test&quot;, [](int &amp;i) {
    mettle::expect(i, equal_to(1));
  });

  mettle::subsuite&lt;std::string&gt;(_, &quot;subsuite&quot;, [](auto &amp;_) {
    _.setup([](int &amp;i, std::string &amp;s) {
      i++;
      s = &quot;foo&quot;;
    });

    _.test(&quot;my subtest&quot;, [](int &amp;i, std::string &amp;s) {
      mettle::expect(i, equal_to(2));
      mettle::expect(s, equal_to(&quot;foo&quot;));
    });
  });
});
</code></pre>

<p>As you can see above, subsuites inherit their parents' fixtures, much like they
inherit their parents' setup and teardown functions.</p>
<h3 id="fixture-factories">Fixture factories<a class="headerlink" href="#fixture-factories" title="Permanent link">§</a></h3>
<p>Sometimes, a fixture can't be constructed as is, e.g if the fixture isn't
default-constructible. In these cases, you can use a <em>fixture factory</em> to create
your fixture object with any parameters you like. For simple cases, we can use
<code>mettle::bind_factory</code>, which takes a list of arguments and constructs an object
of your fixture's type with those arguments:</p>
<pre><code class="c++">mettle::suite&lt;int&gt;
bound_fixture(&quot;using bind_factory&quot;, mettle::bind_factory(3), [](auto &amp;_) {
  _.test([](int &amp;i) {
    mettle::expect(i, equal_to(3));
  });
});
</code></pre>

<p>For more complex fixtures, you can create your own factories from scratch. A
fixture factory is simply an object with a templated <code>make&lt;T&gt;()</code> function:</p>
<pre><code class="c++">struct my_factory {
  template&lt;typename T&gt;
  T make() {
    return T(12);
  }
};

mettle::suite&lt;my_fixture&gt; with_factory(&quot;suite&quot;, my_factory{}, [](auto &amp;_) {
  /* ... */
});
</code></pre>

<p>In fact, even "ordinary" fixtures use their own factory: <code>auto_factory</code>. The
following code snippets are equivalent:</p>
<pre><code class="c++">mettle::suite&lt;my_fixture&gt;
without_auto_factory(&quot;suite&quot;, [](auto &amp;_) {
  /* ... */
});

mettle::suite&lt;my_fixture&gt;
with_auto_factory(&quot;suite&quot;, mettle::auto_factory, [](auto &amp;_) {
  /* ... */
});
</code></pre>

<p>Later, we'll learn more about fixture factories and how to
<a href="#transforming-fixture-types">transform</a> their types.</p>
<h2 id="parameterizing-tests">Parameterizing tests<a class="headerlink" href="#parameterizing-tests" title="Permanent link">§</a></h2>
<p>While suites are a good way to group your tests together, sometimes you want to
run the <em>same</em> tests on several different types of objects. In this case, all
you need to do is specify <em>multiple</em> fixtures when defining a test suite. The
example below creates two test suites, one with a fixture of <code>int</code> and one with
a fixture of <code>float</code>:</p>
<pre><code class="c++">mettle::suite&lt;int, float&gt; param_test(&quot;parameterized suite&quot;, [](auto &amp;_) {
  _.test(&quot;my test&quot;, [](auto &amp;fixture) {
    /* ... */
  });
});
</code></pre>

<p>This works just the same for subsuites as well:</p>
<pre><code class="c++">mettle::suite&lt;&gt; param_sub_test(&quot;parameterized subsuites&quot;, [](auto &amp;_) {
  mettle::subsuite&lt;int, float&gt;(_, &quot;parameterized suite 1&quot;, [](auto &amp;_) {
    /* ... */
  });

  _.template subsuite&lt;int, float&gt;(_, &quot;parameterized suite 2&quot;, [](auto &amp;_) {
    /* ... */
  });
});
</code></pre>

<p>One subtle difference you may have noticed is that now, our test definitions
use a generic lambda: <code>[](auto &amp;fixture) { /* ... */ }</code>. As you might imagine,
this allows the test function to accept a fixture of either an <code>int</code> or a
<code>float</code> and to do the usual thing when a template is instantiated. Of course,
you don't <em>always</em> need to use <code>auto</code> here; if all of your fixtures inherit from
a common base type, you can use an ordinary lambda that takes a reference to the
base type.</p>
<h3 id="transforming-fixture-types">Transforming fixture types<a class="headerlink" href="#transforming-fixture-types" title="Permanent link">§</a></h3>
<p>Earlier, we learned about <a href="#fixture-factories">fixture factories</a>. We can do
even more with them, though: a fixture factory's <code>make&lt;T&gt;()</code> can actually return
<em>any</em> type (including <code>void</code>!), not just <code>T</code>. This can be useful for more
complex tests, like testing a container type with several different element
types:</p>
<pre><code class="c++">struct vector_factory {
  template&lt;typename T&gt;
  std::vector&lt;T&gt; make() {
    return {};
  }
};

mettle::suite&lt;int, float&gt; vector_suite(&quot;suite&quot;, vector_factory{}, [](auto &amp;_) {
  _.test(&quot;empty()&quot;, [](auto &amp;vec) {
    mettle::expect(vec.empty(), equal_to(true));
  });
});
</code></pre>

<h3 id="type-only-fixtures">Type-only fixtures<a class="headerlink" href="#type-only-fixtures" title="Permanent link">§</a></h3>
<p>As mentioned above, a fixture factory's <code>make&lt;T&gt;()</code> can return <code>void</code>. In this
case, the suite has no fixture whatsoever. This is primarily useful when you
want to parameterize on a list of types, but you don't want to automatically
instantiate the fixture object. The built-in fixture factory <code>type_only</code> handles
this for you. In particular, note the parameter-less test function:</p>
<pre><code class="c++">mettle::suite&lt;int, float&gt; type_only(&quot;suite&quot;, mettle::type_only, [](auto &amp;_) {
  _.test(&quot;empty()&quot;, []() {
    /* ... */
  });
});
</code></pre>

<h3 id="getting-the-parameterized-type">Getting the parameterized type<a class="headerlink" href="#getting-the-parameterized-type" title="Permanent link">§</a></h3>
<p>In some cases, you may want to know the parameterized type, e.g. if you'd like
to create your own instances of the object. You can retrieve this via the
<code>fixture_type</code> trait (or the <code>fixture_type_t</code> alias) like so:</p>
<pre><code class="c++">mettle::suite&lt;int, float&gt; param_type(&quot;suite&quot;, mettle::type_only, [](auto &amp;_) {
  using Fixture = mettle::fixture_type_t&lt;decltype(_)&gt;;

  _.test(&quot;my test&quot;, []() {
    /* use Fixture here */
  });
});
</code></pre>

<h2 id="test-attributes">Test attributes<a class="headerlink" href="#test-attributes" title="Permanent link">§</a></h2>
<p>For large projects with many tests, it can be useful to run only a subset of
them, instead of the entire collection. While splitting up tests by file can
help, it doesn't allow for very precise control of what tests get run. Instead,
you can apply attributes to your tests (or whole suites!) and filter on them.</p>
<h3 id="the-skip-attribute">The <em>skip</em> attribute<a class="headerlink" href="#the-skip-attribute" title="Permanent link">§</a></h3>
<p>mettle provides one built-in attribute: <code>mettle::skip</code>. As the name implies,
this attribute causes a test to be skipped by default. This can be useful when a
test is broken, since the test runner will keep track of the skipped tests as a
reminder that you need to go back and fix the test. You can also provide a
comment for the skipped test that will be shown in the test logs explaining why
it was skipped.</p>
<p>For more information about how to use the <code>skip</code> attribute, see <a href="#using-attributes">Using
Attributes</a> below.</p>
<h3 id="defining-attributes">Defining attributes<a class="headerlink" href="#defining-attributes" title="Permanent link">§</a></h3>
<p>In addition to the built-in <code>skip</code> attribute, you can define your own
attributes. There are three basic kinds of attributes, differentiated by the
number of values each can hold: <code>mettle::bool_attr</code>, which holds 0 or 1 values;
<code>mettle::string_attr</code>, which holds exactly 1 value; and <code>mettle::list_attr</code>,
which holds 1 or more distinct values.</p>
<p><code>bool_attr</code>s are somewhat special and can be given a default action
when they're encountered (either <code>mettle::attr_action::run</code> or
<code>mettle::attr_action::skip</code>). As you might be able to guess, the predefined
<code>skip</code> attribute is just a <code>bool_attr</code> whose action is <code>attr_action::skip</code>.</p>
<p>To define an attribute, you just need to create a global instance of one of the
aforementioned attribute kinds:</p>
<pre><code class="c++">mettle::bool_attr slow(&quot;slow&quot;);
mettle::bool_attr busted(&quot;busted&quot;, attr_action::skip);
mettle::list_attr tags(&quot;tags&quot;);
</code></pre>

<h3 id="using-attributes">Using attributes<a class="headerlink" href="#using-attributes" title="Permanent link">§</a></h3>
<p>It's easy to apply attributes to your tests: simply create instances of each
kind of attribute you want, and pass them to the test creation function
immediately after the test name:</p>
<pre><code class="c++">_.test(&quot;my test&quot;, {mettle::skip, slow(&quot;takes too long&quot;), tags(&quot;cat&quot;, &quot;goat&quot;)},
       [](auto &amp;fixture) { /* ... */ });
</code></pre>

<p>This creates a <code>mettle::attributes</code> object that gets stored alongside the test.
As you might notice, <code>bool_attrs</code> can be implicitly converted to an attribute
instance, but other types require you to call them to list their values.</p>
<h4 id="suite-attributes">Suite attributes<a class="headerlink" href="#suite-attributes" title="Permanent link">§</a></h4>
<p>Like tests, whole suites can have attributes associated with them; these are
applied the same way as for tests, and the list of attributes will automatically
be inherited by any children (tests or subsuites). The children can set their
own attributes, and all the attributes in the hierarchy will be combined
together for each test.</p>
<p>For <code>bool_attr</code>s and <code>string_attr</code>s, children with the same attribute as their
parents will <em>override</em> the parent's attribute, but for <code>list_attr</code>s, the
values from the parent and child will be merged:</p>
<pre><code class="c++">mettle::suite&lt;&gt;
attr_suite(&quot;my suite&quot;, {mettle::skip(&quot;broken&quot;), tags(&quot;cat&quot;)}, [](auto &amp;_) {
  _.test(&quot;my test&quot;, {slow, mettle::skip(&quot;fixme&quot;), tags(&quot;dog&quot;)}, []() {
    /* This test has the following attributes: slow, skip(&quot;fixme&quot;), and
       tags(&quot;cat&quot;, &quot;dog&quot;). */
  });
});
</code></pre>

<h4 id="mixing-fixture-factories-and-attributes">Mixing fixture factories and attributes<a class="headerlink" href="#mixing-fixture-factories-and-attributes" title="Permanent link">§</a></h4>
<p>At this point, you may be wondering how to specify <em>both</em> a fixture factory and
a set of attributes for suite. Since they're both optional arguments that appear
between the suite's name and its creation function, which goes first? <em>The
attributes always go first</em>:</p>
<pre><code class="c++">mettle::suite&lt;int&gt;
the_works(&quot;my complicated suite&quot;, {mettle::skip}, type_only, [](auto &amp;_) {
  /* ... */
});
</code></pre>

<p>There's an easy rule to remember this: since attributes are a way of identifying
the suite, they go near the other identifier: the name. Likewise, fixture
factories affect how the suite is <em>executed</em>, so they go near the creation
function, which also affects its execution.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2014-2016 Jim Porter</p>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script><div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
